---
title: "Online Supplementary Material"
author: "From the manuscript: Queen pheromones have conserved effects on gene expression in ants and bees"
output:
  html_document:
    toc: true 
    toc_float: true # make 
    depth: 3  
    number_sections: false 
    theme: yeti 
    code_folding: hide #
---

This document was prepared in R Markdown, then translated into html using the R package `knitr`. Press the buttons labelled **Code** to show or hide the R code used to produce each table, plot or statistical result. You can also select 'Show all code' in the top left corner.


### Load R libraries (install first from CRAN or Bioconductor)
```{r message=FALSE, warning=FALSE, results="hide"}
library(GOstats) # GO term hypergeometric tests - load early so it doesn't clash with dplyr::select etc
library(WGCNA) # Gene networks - needs 'impute' dependency: source("https://bioconductor.org/biocLite.R"); biocLite("impute")
library(RSQLite) # Access SQLite databases
library(reshape2) # data tidying (melt)
library(dplyr) # data tidying
library(tidyr) # data tidying
library(stringr) # string manipulation
library(ggplot2) # for plots
library(ggrepel) # for plots
library(ggdendro) # for plots
library(gridExtra) # for plots
library(RColorBrewer) # for plots
library(ggjoy) # for plots
library(gplots) # Venn diagram
library(ecodist) # for nmds
library(MuMIn) # for model comparison
library(sva) # for ComBat function; install via source("https://bioconductor.org/biocLite.R"); biocLite("sva")
library(pander) # for nice tables
library(kableExtra) # For scrollable tables

kable.table <- function(df) {
  kable(df, "html") %>%
  kable_styling() %>%
  scroll_box(height = "300px")
}

# Open database connections (Sasha uses SQL, Luke prefers dplyr)
db <- dbConnect(SQLite(), dbname="data/queen_pheromone.db")
my_db <- src_sqlite("data/queen_pheromone.db")

# These 4 samples should NOT be used (See below). They were also removed in all non-R analyses (e.g. differential gene expression analyses using EBseq)
bad.samples <- c("lf1", "ln1", "ln12", "lf12")
```

```{r echo=FALSE, results='hide'}
library(knitr) # set up cacheing to save time when re-building html document
```
`r opts_chunk$set(cache=TRUE)`

```{r echo=FALSE, results='hide'}
table.counter <- 1
figure.counter <- 2
supp.table.counter <- 1
supp.figure.counter <- 1

numbering <- function(type){
  focal.number <- get(type)
  assign(type, get(type) + 1, envir = globalenv()) 
  focal.number
}
```

### First let's check for and remove strongly outlying samples

```{r make.OGGs}
  # Define a function to get gene expression data for a given set of orthologous genes. We define orthologous genes as those that are each other's reciprocal best BLAST. The bad.samples argument can be used to remove some named samples. By default this function logs the expression data (using log10). It returns a list with two elements: the first element is a matrix of expression data (rows = samples, cols = genes), and the second is a data frame giving the species-specific names of the orthologous genes
make.OGGs <- function(species, bad.samples = NULL, log.data = T){
  
  # set up forward mappings, e.g. "am2bt", "am2lf", "am2ln"
  forward.mappings <- paste(species[1], "2", species[2:length(species)], sep = "")
  # and reverse mappings, e.g. "bt2am", "lf2am", "ln2am"
  backward.mappings <- paste(species[2:length(species)], "2", species[1], sep = "")
  items <- list() # declare empty list

  for(i in 1:length(forward.mappings)){
    
    # make a table with 3 columns: first column has species 1 gene,
    # second column has species 2 gene in forward mapping,
    # third column has species 2 gene in reverse mapping (this can be NA, or different to col 2)
    # we want the rows where cols 2 and 3 are the same, indicating reciprocity in the BLAST
    focal <- left_join(
      tbl(my_db, forward.mappings[i]) %>% 
        dplyr::select(-evalue), # get the two mappings and 
      tbl(my_db, backward.mappings[i]) %>% 
        dplyr::select(-evalue), # merge by species 1 column
      by = species[1]
    ) %>% 
      collect(n=Inf) %>% as.data.frame  # collect it all and convert to df
    
    # Get the RBB rows, and keep the two relevant columns
    focal <- focal[!is.na(focal[,3]), ]
    items[[i]] <- focal[focal[,2] == focal[,3], 1:2] 
  }
  rbbs <- items[[1]] # If 3 or 4 species, successively merge the results
  if(length(items) > 1) rbbs <- left_join(rbbs, items[[2]], by = species[1])
  if(length(items) > 2) rbbs <- left_join(rbbs, items[[3]], by = species[1])
  
  # Throw out species1 genes that do not have a RBB in all species
  rbbs <- rbbs[complete.cases(rbbs), ]
  names(rbbs) <- gsub("[.]x", "", names(rbbs)) # tidy the row and column names
  rownames(rbbs) <- NULL

  # Make sure the columns are ordered as in 'species'
  rbbs <- rbbs[, match(names(rbbs), species)]

  # We know have a list of the names of all the ortholgous genes in each species
  # Now we use these names to look up the gene expression data for each ortholog
  expression.tables <- paste("rsem_", species, sep = "")
  
  for(i in 1:length(species)){
    focal.expression <- tbl(my_db, expression.tables[i]) %>% 
      collect(n=Inf) %>% as.data.frame()
    names(focal.expression)[names(focal.expression) == "gene"] <- species[i]
    rbbs <- left_join(rbbs, focal.expression, by = species[i])
  }
  gene.name.mappings <- rbbs[, names(rbbs) %in% species] # save gene name mappings in separate DF
  
  rownames(rbbs) <- rbbs[,1] # Use the gene names for species 1 as row names
  rbbs <- rbbs[, !(names(rbbs) %in% species)] # remove gene name columns 
  rbbs <- t(as.matrix(rbbs))

  if(log.data) rbbs <- log10(1 + rbbs)
  if(!is.null(bad.samples)) rbbs <- rbbs[!(rownames(rbbs) %in% bad.samples), ]
  
  # Discard genes where NAs appear
  gene.name.mappings <- gene.name.mappings[!(is.na(colSums(rbbs))), ]
  rbbs <- rbbs[, !(is.na(colSums(rbbs)))]

  # discard genes where expression is zero for all samples in 1 or more species
  spp <- str_replace_all(rownames(rbbs), "[:digit:]", "")
  to.keep <- rep(TRUE, ncol(rbbs))
  for(i in 1:ncol(rbbs)){
   if(min(as.numeric(tapply(rbbs[,i], spp, sum))) == 0) to.keep[i] <- FALSE
 }
rbbs <- rbbs[, to.keep]
gene.name.mappings <- gene.name.mappings[to.keep, ]

  list(tpm = rbbs, gene.mappings = gene.name.mappings)
}
```


#### 4 of the _Lasius_ samples are highly different to all of the rest
Closer inspection reveals that they have zeros for many of the transcripts, so perhaps they had low abundance libraries.
```{r outliers}
set.seed(1) # nmds involves random numbers, so make this plot reproducible
expression.data <- make.OGGs(c("am", "bt", "ln", "lf"))[[1]]
treatments <- tbl(my_db, "treatments") %>% as.data.frame()

shhh <- capture.output(nmds.output <- dist(expression.data) %>% nmds())
data.frame(id = rownames(expression.data), nmds.output$conf[[length(nmds.output$conf)]], stringsAsFactors = F) %>%
  left_join(treatments, by = "id") %>% 
  rename(Species = species, Treatment = treatment) %>%
  ggplot(aes(X1,X2, shape = Species)) + 
  geom_point(aes(colour = Treatment)) + 
  geom_text_repel(aes(label = id), size=3.6) + 
  xlab("NMDS 1") + ylab("NMDS 2")
```
 <br/><br/> 
**Figure S`r numbering("supp.figure.counter")`**: After reducing the transcriptome data to two axes using non-metric multidimensional scaling, four _Lasius_ samples are clear outliers.


```{r no.outliers}
set.seed(1) # nmds involves random numbers, so make this plot reproducible
expression.data <- make.OGGs(c("am", "bt", "ln", "lf"), bad.samples = bad.samples)[[1]]

shhh <- capture.output(nmds.output <- dist(expression.data) %>% nmds())
data.frame(id = rownames(expression.data), 
           nmds.output$conf[[length(nmds.output$conf)]], 
           stringsAsFactors = F) %>%
  left_join(treatments, by = "id") %>%
  rename(Species = species, Treatment = treatment) %>% 
  ggplot(aes(X1,X2)) + 
  geom_point(aes(shape = Species, colour = Treatment)) + 
  geom_text_repel(aes(label = id), size=3.6) + 
  xlab("NMDS 1") + ylab("NMDS 2")
```
 <br/><br/> 
 **Figure S`r numbering("supp.figure.counter")`**: With the four problematic samples removed, the samples cluster according to species with no obvious outliers.
 
## Table of sample sizes
**Table S`r numbering("supp.table.counter")`**: Number of sequencing libraries for each combination of species and treatment, after removing the four problematic libraries. Each library was prepared from a pool of workers, taken from the same colony. 
```{r sample.size.table}
sample.size.table <- treatments[treatments$id %in% rownames(expression.data),] %>% 
  group_by(species, treatment) %>% 
  summarise(n = n()) %>% as.data.frame()
names(sample.size.table) <- c("Species", "Treatment", "Number of RNAseq libraries")
sample.size.table %>% pander()
```


## Lists of significantly differentially expressed genes
```{r de.gene.tables}
apis.de <- suppressMessages(tbl(my_db, "ebseq_padj_gene_am") %>% 
  select(gene, PostFC) %>% 
    left_join(tbl(my_db, "bee_names")) %>% 
    collect() %>% 
  mutate(PostFC = round(log2(PostFC), 3)) %>% 
    select(gene, name, PostFC) %>% 
    rename(Gene=gene, Name=name, Log2_FC = PostFC) %>% 
    arrange(-abs(Log2_FC))) %>% as.data.frame()

bombus.de <- suppressMessages(tbl(my_db, "ebseq_padj_gene_bt") %>% 
  select(gene, PostFC) %>% 
    left_join(tbl(my_db, "bt2am") %>% rename(gene=bt)) %>% 
    left_join(tbl(my_db, "bee_names") %>% rename(am=gene)) %>% 
    collect() %>%
   mutate(PostFC = round(log2(PostFC), 3), name = replace(name, is.na(name), " "), 
          am = replace(am, is.na(am), " ")) %>% 
  select(gene, am, name, PostFC) %>% 
    rename(Gene=gene, Apis_BLAST=am, Name=name, Log2_FC = PostFC) %>% 
    arrange(-abs(Log2_FC))) %>% as.data.frame()

flavus.de <- suppressMessages(tbl(my_db, "ebseq_padj_gene_lf") %>% 
  select(gene, PostFC) %>% 
    left_join(tbl(my_db, "lf2am") %>% rename(gene=lf)) %>% 
    left_join(tbl(my_db, "bee_names") %>% rename(am=gene)) %>% 
    collect() %>%
   mutate(PostFC = round(log2(PostFC), 3), name = replace(name, is.na(name), " "), 
          am = replace(am, is.na(am), " ")) %>% 
  select(gene, am, name, PostFC) %>% 
    rename(Gene=gene, Apis_BLAST=am, Name=name, Log2_FC = PostFC) %>%
    arrange(-abs(Log2_FC))) %>% as.data.frame()

niger.de <- suppressMessages(tbl(my_db, "ebseq_padj_gene_ln") %>% 
  select(gene, PostFC) %>% 
    left_join(tbl(my_db, "ln2am") %>% rename(gene=ln)) %>% 
    left_join(tbl(my_db, "bee_names") %>% rename(am=gene)) %>% 
    collect() %>%
   mutate(PostFC = round(log2(PostFC), 3), name = replace(name, is.na(name), " "), 
          am = replace(am, is.na(am), " ")) %>% 
  select(gene, am, name, PostFC) %>% 
    rename(Gene=gene, Apis_BLAST=am, Name=name, Log2_FC = PostFC) %>% 
    arrange(-abs(Log2_FC))) %>% as.data.frame()

names(apis.de) <- gsub("_", " ", names(apis.de))
names(bombus.de) <- gsub("_", " ", names(bombus.de))
names(flavus.de) <- gsub("_", " ", names(flavus.de))
names(niger.de) <- gsub("_", " ", names(niger.de))
```

### DE genes for _Apis mellifera_
**Table S`r numbering("supp.table.counter")`**: List of the `r nrow(apis.de)` significantly differentially expressed genes (EBseq; p < 10^-5^) in _Apis mellifera_, listed in order of fold change in gene expression on a Log$_2$ scale. Positive fold change values indicate higher expression in the control, while negative values indicate higher expression in the queen pheromone treatment.
```{r apis.de}
kable.table(apis.de)
```

### DE genes for _Bombus terrestris_
**Table S`r numbering("supp.table.counter")`**: The single differentially expressed gene (EBseq; p < 10^-5^) in _Bombus terrestris_. Positive fold change values indicate higher expression in the control, while negative values indicate higher expression in the queen pheromone treatment. The second and third columns give the best BLAST hit for this gene in _A. mellifera_ plus the name of the _A. mellifera_ putative ortholog. 
```{r}
kable(bombus.de, "html") %>%
  kable_styling()
```

### DE genes for _Lasius flavus_
**Table S`r numbering("supp.table.counter")`**: List of the `r nrow(flavus.de)` significantly differentially expressed genes (EBseq; p < 10^-5^) in _Lasius flavus_, listed in order of fold change in gene expression on a Log$_2$ scale. Positive fold change values indicate higher expression in the control, while negative values indicate higher expression in the queen pheromone treatment. The second and third columns give the best BLAST hit for this gene in _A. mellifera_ plus the name of the _A. mellifera_ putative ortholog. 
```{r}
kable.table(flavus.de)
```

### DE genes for _Lasius niger_
**Table S`r numbering("supp.table.counter")`**: List of the `r nrow(niger.de)` significantly differentially expressed genes (EBseq; p < 10^-5^) in _Lasius niger_, listed in order of fold change in gene expression on a Log$_2$ scale. Positive fold change values indicate higher expression in the control, while negative values indicate higher expression in the queen pheromone treatment. The second and third columns give the best BLAST hit for this gene in _A. mellifera_ plus the name of the _A. mellifera_ putative ortholog. 
```{r}
kable.table(niger.de)
```



## Genes that are differentially expressed in multiple species
In the first pair of tables, we have simply listed the genes that showed statistically significant differential expression in two or more species. This method makes few false positives, but it likely misses many of true overlaps because our study has modest power to detect differential expression.

In the third table, we instead look for similarities between species using a method that ranks genes from most- to least- phermone sensitive based on log fold change, alleviating the problem of . To do this, we select the top _n_ genes per species (where _n_ = 100, 200 ... 500), based on the absolute magnitude of the log fold-change response to queen pheromone, giving a list of the most pheromone-sensitive genes. We beleive that this alternative method likely produces fewer false negatives in our search for overlapping genes, at cost of getting more false positives.

```{r find.intersect, messages = FALSE, warnings = FALSE, results = "hide"}
# Define a function to test whether the overlap of two sets of differentially expressed genes, 
# drawn from a common pool (e.g. all the orthologs that were tested), is higher or lower than expected
# Inspiration for this code: https://stats.stackexchange.com/questions/10328/using-rs-phyper-to-get-the-probability-of-list-overlap
overlap.hypergeometric.test <- function(n.overlaps, num.sig1, num.sig2, num.genes, species){
  p.smaller <- phyper(n.overlaps, num.sig1, num.genes - num.sig1, num.sig2) 
  p.higher <- 1 - phyper(n.overlaps - 1, num.sig1, num.genes - num.sig1, num.sig2)
  output <- data.frame(Species = species,
                       Test = c("Overlap is lower than expected:",
                                  "Overlap is higher than expected:"),
                       p = c(p.smaller, p.higher))
  output[output$p == min(output$p), ]
}



# Apis and flavus
af.oggs <- make.OGGs(c("am", "lf"))[[2]] # Get the orthologous gene list
n.am <- (tbl(my_db, "ebseq_padj_gene_am") %>% 
           filter(gene %in% af.oggs$am) %>% 
           summarise(n=n()) %>% 
           as.data.frame())[1,1] # Count the number of diff expressed genes that appear in the OGG list
n.lf <- (tbl(my_db, "ebseq_padj_gene_lf") %>% 
           filter(gene %in% af.oggs$lf) %>% summarise(n=n()) %>% 
           as.data.frame())[1,1]
num.oggs.af <- nrow(af.oggs) # Count the orthologous genes
af.oggs <- suppressMessages(
  af.oggs %>% 
    filter(am %in% (tbl(my_db, "ebseq_padj_gene_am") %>% 
                      as.data.frame())[,1],
           lf %in% (tbl(my_db, "ebseq_padj_gene_lf") %>% 
                      as.data.frame())[,1]) %>% 
    mutate(Species = "Apis and L. flavus") %>% 
    left_join(tbl(my_db, "ebseq_gene_am") %>% 
                select(gene, PostFC) %>% 
                rename(am=gene), copy=T) %>% 
    rename(`Apis FC` = PostFC) %>%
    left_join(tbl(my_db, "ebseq_gene_lf") %>% 
                select(gene, PostFC) %>% 
                rename(lf=gene), copy=T) %>% 
    rename(`L. flavus FC` = PostFC) %>%
    left_join(tbl(my_db, "bee_names") %>% 
                rename(am=gene), copy=T))
num.overlap.af <- nrow(af.oggs) # Count the overlaps
test1 <- overlap.hypergeometric.test(num.overlap.af, 
                                     n.am, n.lf, 
                                     num.oggs.af, 
                                     "Apis and L. flavus") # Run the hypergeometric test


# Apis and niger
an.oggs <- make.OGGs(c("am", "ln"))[[2]] # Get the orthologous gene list
n.am <- (tbl(my_db, "ebseq_padj_gene_am") %>% 
           filter(gene %in% an.oggs$am) %>% 
           summarise(n=n()) %>% as.data.frame())[1,1] # Count the number of diff expressed genes that appear in the OGG list
n.ln <- (tbl(my_db, "ebseq_padj_gene_ln") %>% 
           filter(gene %in% an.oggs$ln) %>% 
           summarise(n=n()) %>% as.data.frame())[1,1]
num.oggs.an <- nrow(an.oggs) # Count the orthologous genes
an.oggs <- suppressMessages(
  an.oggs %>% 
    filter(am %in% (tbl(my_db, "ebseq_padj_gene_am") %>% as.data.frame())[,1],
           ln %in% (tbl(my_db, "ebseq_padj_gene_ln") %>% as.data.frame())[,1]) %>% 
    mutate(Species = "Apis and L. niger") %>% 
    left_join(tbl(my_db, "ebseq_gene_am") %>% 
                select(gene, PostFC) %>% 
                rename(am=gene), copy=T) %>% 
    rename(`Apis FC` = PostFC) %>%
    left_join(tbl(my_db, "ebseq_gene_ln") %>% 
                select(gene, PostFC) %>% 
                rename(ln=gene), copy=T) %>% 
    rename(`L. niger FC` = PostFC) %>%
    left_join(tbl(my_db, "bee_names") %>% 
                rename(am=gene), copy=T))
num.overlap.an <- nrow(an.oggs) # Count the overlaps
test2 <- overlap.hypergeometric.test(num.overlap.an, n.am, n.ln, num.oggs.an, "Apis and L. niger") # Run the hypergeometric test

# flavus and niger
fn.oggs <- make.OGGs(c("lf", "ln"))[[2]] # Get the orthologous gene list
n.lf <- (tbl(my_db, "ebseq_padj_gene_lf") %>% 
           filter(gene %in% fn.oggs$lf) %>%
           summarise(n=n()) %>% as.data.frame())[1,1] # Count the number of diff expressed genes that appear in the OGG list
n.ln <- (tbl(my_db, "ebseq_padj_gene_ln") %>% 
           filter(gene %in% fn.oggs$ln) %>% 
           summarise(n=n()) %>% as.data.frame())[1,1]
num.oggs.fn <- nrow(fn.oggs) # Count the orthologous genes
fn.oggs <- suppressMessages(
  fn.oggs %>% filter(ln %in% (tbl(my_db, "ebseq_padj_gene_ln") %>% as.data.frame())[,1],
                     lf %in% (tbl(my_db, "ebseq_padj_gene_lf") %>% as.data.frame())[,1]) %>% 
    mutate(Species = "L. flavus and L. niger") %>% 
    left_join(tbl(my_db, "ebseq_gene_lf") %>% 
                select(gene, PostFC) %>% 
                rename(lf=gene), copy=T) %>% 
    rename(`L. flavus FC` = PostFC) %>%
    left_join(tbl(my_db, "ebseq_gene_ln") %>% 
                select(gene, PostFC) %>% 
                rename(ln=gene), copy=T) %>% 
    rename(`L. niger FC` = PostFC) %>%
    left_join(tbl(my_db, "lf2am"), copy=T) %>%
    left_join(tbl(my_db, "bee_names") %>% 
                rename(am=gene), copy=T))
num.missing <- sum(is.na(fn.oggs$name))
fn.oggs$name[is.na(fn.oggs$name)] <- paste("Unknown gene", 1:num.missing)
num.overlap.fn <- nrow(fn.oggs) # Count the overlaps
test3 <- overlap.hypergeometric.test(num.overlap.fn, 
                                     n.lf, n.ln, 
                                     num.oggs.fn, 
                                     "L. flavus and L. niger") # Run the hypergeometric test


overlaps <- suppressMessages(
  data.frame(name = unique(c(af.oggs$name, an.oggs$name, fn.oggs$name)), 
             stringsAsFactors = F) %>%
    left_join(rbind(af.oggs %>% select(name, starts_with("Apis")),
                    an.oggs %>% select(name, starts_with("Apis")))) %>%
    left_join(rbind(af.oggs %>% select(name, ends_with("flavus FC")),
                    fn.oggs %>% select(name, ends_with("flavus FC")))) %>%
    left_join(rbind(an.oggs %>% select(name, ends_with("niger FC")),
                    fn.oggs %>% select(name, ends_with("niger FC")))) %>% distinct())
overlaps <- rbind(overlaps[overlaps$name == "myosin light chain alkali-like isoform X5", ],
                  overlaps[overlaps$name != "myosin light chain alkali-like isoform X5", ])
overlaps$Consistent <- "Yes"
overlaps$Consistent[apply(overlaps[,2:4],1,min,na.rm=T)<1 & apply(overlaps[,2:4],1,max,na.rm=T)>1] <- "No"
for(i in 2:4) overlaps[,i] <- format(round(log2(overlaps[,i]), 3), nsmall = 3) 
overlaps[overlaps == "    NA"] <- " "
rownames(overlaps) <- NULL

overlap.p.values <- rbind(test1, test2, test3) 
rownames(overlap.p.values) <- NULL

all.overlaps <- c(af.oggs$am, an.oggs$am, fn.oggs$am[!is.na(fn.oggs$am)]) %>% unique
```

**Table S`r numbering("supp.table.counter")`**: All orthologous genes that were significantly differentially expressed between pheromone treatments in more than one species. The FC columns give the Log$_2$ fold-change in expression for each species where the focal gene was significantly differentially expressed, where positive numbers mean it was expressed at a higher level in control animals. The last column highlights genes that responded to treatment in a consistent or inconsistent direction across species. _B. terrestris_ is omitted because neither of its differentially expressed genes were significantly affected by treatment in the other three species.
```{r overlap.table}
kable.table(overlaps)
```

<br></br>
**Table S`r numbering("supp.table.counter")`**: The overlap between the lists of significantly differently expressed orthologous genes was significantly higher than expected for _L. flavus_ and _L. niger_, suggesting that queen pheromone has conserved effects on gene expression between these two species (results based on a hypergeometric test). For the other two species pairs, the number of overlapping genes was not higher or lower than expected under the null hypothesis that queen pheromone affects a random set of genes in each species.
```{r overlap.table.p}
pander(overlap.p.values, split.cell = 40, split.table = Inf)
```


```{r results = "hide", warning=FALSE}
most.pheromone.sensitive.genes <- function(){
  ngenes.list <- (1:5)*100 # 100 - 500
  dat <- list()
  for(i in 1: length(ngenes.list)){
    ngenes <- ngenes.list[i]
    
    # Get the top n genes from Apis, as ranked by the absolute value for the log-fold change in response to pheromone
    g1 <- tbl(my_db, "ebseq_gene_am") %>% collect() %>% 
      select(gene, PostFC) %>% 
      mutate(PostFC = log2(PostFC)) %>% left_join(tbl(my_db, "bee_names"), copy=TRUE, by = "gene") %>% 
      arrange(-abs(PostFC)) %>% head(ngenes) %>% .$name %>% unique()
    
    # Do the same for genes from non-Apis species, and get the Apis names for the top BLAST hits in the Apis genome
    g2 <- tbl(my_db, "ebseq_gene_bt") %>% 
      select(gene, PostFC) %>% 
      left_join(tbl(my_db, "bt2am") %>% 
                  rename(gene = bt) %>% 
                  select(-evalue), by = "gene") %>%
      collect() %>% mutate(PostFC = log2(PostFC)) %>% 
      arrange(-abs(PostFC)) %>% 
      rename(bt = gene, gene = am) %>% 
      left_join(tbl(my_db, "bee_names"), copy=TRUE, by = "gene") %>% 
      filter(!is.na(name)) %>% head(ngenes) %>% .$name %>% unique()
    
    g3 <- tbl(my_db, "ebseq_gene_lf") %>% 
      select(gene, PostFC) %>% 
      left_join(tbl(my_db, "lf2am") %>% 
                  rename(gene = lf) %>% 
                  select(-evalue), by = "gene") %>%
      collect() %>% mutate(PostFC = log2(PostFC)) %>% 
      arrange(-abs(PostFC)) %>% 
      rename(lf = gene, gene = am) %>% 
      left_join(tbl(my_db, "bee_names"), copy=TRUE, by = "gene") %>% 
      filter(!is.na(name)) %>% head(ngenes) %>% .$name %>% unique()
    
    g4 <-tbl(my_db, "ebseq_gene_ln") %>% 
      select(gene, PostFC) %>% 
      left_join(tbl(my_db, "ln2am") %>% 
                  rename(gene = ln) %>% 
                  select(-evalue), by = "gene") %>%
      collect() %>% mutate(PostFC = log2(PostFC)) %>% 
      arrange(-abs(PostFC)) %>% 
      rename(ln = gene, gene = am) %>% 
      left_join(tbl(my_db, "bee_names"), copy=TRUE, by = "gene") %>% 
      filter(!is.na(name)) %>% head(ngenes) %>% .$name %>% unique()
    
    # Count the number of intersections, and find gene names that appear in 3 or 4 species using the venn() function
    venn.diagram <- venn(list(am=g1, bt=g2, lf=g3, ln=g4), show.plot=FALSE) 
    three.plus <- attr(venn.diagram, "intersections")[str_count(names(attr(venn.diagram, "intersections")), ":") > 1] %>% 
      unlist %>% unname %>% unique %>% sort
    four <- attr(venn.diagram, "intersections")[str_count(names(attr(venn.diagram, "intersections")), ":") > 2] %>% 
      unlist %>% unname %>% unique %>% sort
    three <- three.plus[!(three.plus %in% four)]
    if(length(three) + length(four) > 0) dat[[i]] <- data.frame(Name = c(three, four), 
                                                                count = c(rep("x3 species", length(three)), 
                                                                          rep("4 species", length(four))), 
                                                                nGenes = ngenes, stringsAsFactors = FALSE)
  }
  dat <- do.call("rbind", dat) %>%
    arrange(count, nGenes, Name) %>%
    distinct(paste(Name, count), .keep_all = TRUE) %>%
    select(Name, count, nGenes) %>%
    mutate(count = replace(count, count == "x3 species", "3 species")) 
  
  names(dat) <- c("Name", "Appears in", "Size of gene set")
  dat
}
most.pheromone.sensitive.genes <- most.pheromone.sensitive.genes()
```

**Table S`r numbering("supp.table.counter")`**: List of genes that appear in the top _n_-most pheromone-sensitive genes for 3 or 4 species. To generate the table, we ranked genes by the absolute value of their log fold change in response to queen pheromone, then listed the gene names that appeared in 3-4 species. For non-_Apis_ species, we found the gene names by comparison with the _Apis_ genome by BLAST. This exercise was performed with _n_ = 100, 200 ... 500, and the third column lists the smallest _n_ for which the gene in question appeared (for example, the gene _protein takeout-like_ appeared for all 4 species when inspecting the top 200+ genes). 
```{r}
kable(most.pheromone.sensitive.genes, "html") %>%
  kable_styling() %>%
  scroll_box(height = "300px")
```




## Most pheromone-sensitive genes are evolutionarily ancient
We defined a gene as "evolutionarily ancient" if it has an ortholog in at least one species from the other lineage (for example, we define ancient _A. mellifera_ genes as those that have a reciprocal best BLAST hit in one or both _Lasius_ species). Genes that were not detected by BLAST in the other lineage were defined as putatively lineage-specific (though many of them are likely to be conserved genes that we failed to identify as such, hence the word "putative"). Using a Chi-square test, we find that genes that are significantly differentially expressed in response to queen pheromone are more likely to be ancient than those that are not differentially exressed. This relationship holds for all three species for which we found differential expression, and for genes that were higher or lower in the pheromone treatment. The fact that we probably miscalssifed many genes as ancient vs lineage-specific means that the result is likely to be even stronger than suggested here.
```{r}
ancient.genes.test <- function(species){   
 if(species == "am") ancient.genes <- c(make.OGGs(c("am", "lf"))[[2]]$am, 
                                        make.OGGs(c("am", "ln"))[[2]]$am) %>% unique
 if(species == "bt") ancient.genes <- c(make.OGGs(c("bt", "lf"))[[2]]$bt, 
                                        make.OGGs(c("bt", "ln"))[[2]]$bt) %>% unique
 if(species == "lf") ancient.genes <- c(make.OGGs(c("lf", "am"))[[2]]$lf, 
                                        make.OGGs(c("lf", "bt"))[[2]]$lf) %>% unique
 if(species == "ln") ancient.genes <- c(make.OGGs(c("ln", "am"))[[2]]$ln, 
                                        make.OGGs(c("ln", "bt"))[[2]]$am) %>% unique
 lab <- "Putatively bee-specific"
 if(species %in% c("lf", "ln")) lab <- "Putatively ant-specific"
 
 expression <- tbl(my_db, paste("ebseq_gene_", species, sep="")) %>% 
   select(gene, PostFC) %>% collect() %>%
   mutate(age = lab, sig = "Non-sig") %>% as.data.frame()
 expression$age[expression$gene %in% ancient.genes] <- "Evolutionarily ancient"
 expression$sig[expression$gene %in% (tbl(my_db, paste("ebseq_padj_gene_", species, sep="")) %>% 
                                        filter(PostFC < 1) %>% select(gene) %>% collect %>% .$gene)] <- "Up in QP"
 expression$sig[expression$gene %in% (tbl(my_db, paste("ebseq_padj_gene_", species, sep="")) %>% 
                                        filter(PostFC > 1) %>% select(gene) %>% collect %>% .$gene)] <- "Up in Control"
  tab <- table(expression$sig, expression$age)
  chisq.test(tab) %>% print
  percent <- paste("(", (100*tab / rowSums(tab)) %>% round(1) %>% format(nsmall=1), "%)", sep = "")
  for(i in 1:2) {for(j in 1:3) tab[j,i] <- paste(tab[j,i], percent[j + (i-1)*3])}
  tab %>% pander
}
```

### _Apis mellifera_
```{r}
ancient.genes.test("am") 
```

### _Lasius flavus_
```{r}
ancient.genes.test("lf") 
```

### _Lasius niger_
```{r}
ancient.genes.test("ln") 
```



## Correlations in pheromone-sensitive gene expression across species

These tests ask if genes that are up-regulated in the queen pheromone treatment in one species are also up (or down) regulated in another. These tests used fold expression changes calculated using ebseq, after omitting the four irregular Lasius samples. The advantage of these tests is that one is not limited to the set of 'significant' genes, which discards a lot of information based on an arbitrary p-value threshold.

#### Define function to retrieve fold-change expression data (calculated with ebseq) for genes that are each other's reciprocal best BLAST
```{r fc.function}
get.fc.for.pair.species <- function(species1, species2){
  query <- 'SELECT rbb.X AS X_gene, rbb.Y AS Y_gene, ebseq_gene_X.PostFC AS X_fc, ebseq_gene_Y.PostFC AS Y_fc FROM ebseq_gene_X
             JOIN
  (SELECT Y2X.X, Y2X.Y  FROM Y2X
  JOIN X2Y
  ON Y2X.Y = X2Y.Y AND Y2X.X = X2Y.X  ) AS rbb
  ON rbb.X = ebseq_gene_X.gene
  JOIN ebseq_gene_Y
  ON rbb.Y = ebseq_gene_Y.gene'
  
  query <- str_replace_all(query, "X", species1)
  query <- str_replace_all(query, "Y", species2)
  dbGetQuery(db, query)
}
```


#### Make a table and a plot of the correlations for each pair of species
**Table S`r numbering("supp.table.counter")`**: Results of Spearman's rank correlations, testing whether the absolute log fold difference between pheromones treatments is correlated for a given pair of species. Positive coefficients (rho) indicate that on average, orthologous genes have similar sensitivity to queen pheromones. The p-values have been corrected for multiple testing with the Benjamini-Hochberg method.
```{r TableS1}
species.combinations <- t(combn(c("am", "bt", "lf", "ln"), 2))
rho <- numeric(nrow(species.combinations))
p <- numeric(nrow(species.combinations))
for(i in 1:nrow(species.combinations)){
  fc.data <- get.fc.for.pair.species(species.combinations[i, 1], 
                                     species.combinations[i,2])
  fc.data[,3:4] <- fc.data[,3:4] %>% log2 %>% abs # Log the fold changes - not that it matters for Spearman's!
  results <- suppressWarnings(with(fc.data, cor.test(fc.data[,3], 
                                                     fc.data[,4], method="spearman"))) # Spearman's correlation
  rho[i] <- results$estimate
  p[i] <- results$p.value
}

species.combinations <- data.frame(Species1 = species.combinations[,1],
                                   Species2  = species.combinations[,2],
                                   rho = rho,
                                   p = p.adjust(p, method = "BH"), # adjust these p-vals for multiple testing
                                   sig = " ", stringsAsFactors = F)

species.combinations[species.combinations == "am"] <- "Apis mellifera"
species.combinations[species.combinations == "bt"] <- "Bombus terrestris"
species.combinations[species.combinations == "lf"] <- "Lasius flavus"
species.combinations[species.combinations == "ln"] <- "Lasius niger"

species.combinations$sig[species.combinations$p < 0.05] <- "*"
species.combinations$sig[species.combinations$p < 0.01] <- "**"
species.combinations$sig[species.combinations$p < 0.0001] <- "***"
# Make a table
species.combinations %>% mutate(rho = format(round(rho, 3), nsmall = 3)) %>% pander
```

```{r FigureS1}
# Make a figure
heat.map.figure <- species.combinations %>% ggplot(aes(Species1, Species2, fill=rho)) + 
  geom_tile(colour="white", size=4) + 
  scale_fill_gradient2(name = "Corr", 
                       low = brewer.pal(9, "RdYlBu")[7], 
                       mid = "white", 
                       high = brewer.pal(9, "RdYlBu")[2]) + 
  geom_text(aes(label = paste(format(signif(rho, 2), nsmall = 2), sig)), size = 3.5) +
  theme_bw() + theme(panel.grid = element_blank(), 
                     panel.border = element_blank(), 
                     axis.ticks = element_blank(), 
                     axis.text = element_text(face = "italic"), 
                     legend.position = "none") + 
  xlab(NULL) + ylab(NULL) +
  scale_x_discrete(labels = c("Apis\nmellifera", "Bombus\nterrestris", "Lasius\nflavus"), expand = c(0,0)) + 
  scale_y_discrete(labels = c("Bombus\nterrestris", "Lasius\nflavus", "Lasius\nniger"), expand = c(0,0)) 
heat.map.figure
ggsave(heat.map.figure, file = "figures/Correlations heat map.pdf", height = 4, width=4.3)
```
 <br/><br/> 
 **Figure S`r numbering("supp.figure.counter")`**: Results of Spearman's rank correlations, testing whether the fold-change in gene expression in response to queen pheromone is correlated for a given pair of species. The colour shows the correlation (Spearman's rho), where red  indicates that on average, orthologous genes are affected in the same direction by queen pheromones, and blue indicates the reverse. The stars show the degree of statistical significance after FDR correction (\*\* p < 0.01, \*\*\* p < 0.0001).




## Identifying genes that splice differently following queen pheromone treatment

Many genes showed alternative splicing in all four species, with the great majority showing between 1 and 6 isoforms.

```{r}
rbind(my_db %>% tbl("isoforms_am") %>% collect %>% .$gene %>% 
        table %>% melt %>% select(value) %>% mutate(sp = "Apis mellifera"),
      my_db %>% tbl("isoforms_bt") %>% collect %>% .$gene %>% 
        table %>% melt %>% select(value) %>% mutate(sp = "Bombus terrestris"),
      my_db %>% tbl("isoforms_lf") %>% collect %>% .$gene %>% 
        table %>% melt %>% select(value) %>% mutate(sp = "Lasius niger"),
      my_db %>% tbl("isoforms_ln") %>% collect %>% .$gene %>% 
        table %>% melt %>% select(value) %>% mutate(sp = "Lasius flavus")) %>% 
  as.data.frame() %>%
  ggplot(aes(x = value, y = sp, fill = sp)) + 
  geom_joy(stat = "binline", binwidth=1) + 
  coord_cartesian(xlim=c(1,12)) + 
  scale_fill_cyclical(values = c("#4040B0", "#9090F0")) + 
  scale_x_continuous(breaks = seq(1,12,by=1)) + 
  scale_y_discrete(expand = c(0.01, 0)) + 
  theme_joy() + 
  xlab("Number of isoforms") + ylab(NULL) + 
  theme(axis.text = element_text(face = "italic"))
```
 <br/><br/> 
**Figure S`r numbering("supp.figure.counter")`**: Distribution of isoform numbers per gene for each of the four species.

```{r splice.function}
# Define a function to search for significantly alternatively spliced genes. We define these as genes that have at least two differentially expressed isoforms, where queen pheromone stimulates expresison of one isoform but surpresses expression of another

find.alternatively.spliced.genes <- function(species){
  
  # Write a database query with 'X' as a placeholder for the species name
  # We want to find genes in which at least two isoforms are differentially expressed in response to pheromones
  # Significant isoforms are listed in the ebseq_padj_isoform_X tables, so we count them and get the names of their genes
  query <- 'SELECT isoforms_X.gene, isoforms_X.isoform, PostFC FROM isoforms_X
JOIN
             (SELECT gene, COUNT(*) FROM ebseq_padj_isoform_X 
             JOIN isoforms_X
             ON isoforms_X.isoform = ebseq_padj_isoform_X.isoform
             GROUP BY gene
             HAVING COUNT(*)>1 ) AS multiISO
             ON multiIso.gene = isoforms_X.gene
             JOIN ebseq_padj_isoform_X 
             ON ebseq_padj_isoform_X.isoform = isoforms_X.isoform
             ORDER BY isoforms_X.gene'
  query <- str_replace_all(query, "X", species) # replace X with the species
  Splice <- dbGetQuery(db, query) # run the query

  # Find the highest and lowest fold change for the isoforms of each gene
  SpliceMin <- aggregate(Splice$PostFC, by=list(Splice$gene), FUN="min")
  SpliceMax <- aggregate(Splice$PostFC, by=list(Splice$gene), FUN="max")
  SpliceCompare <- merge(SpliceMin, SpliceMax, by = "Group.1")
  colnames(SpliceCompare) <- c("gene", "min", "max")
  
  # Define diff-spliced genes as those with both elevated and 
  # repressed isoforms, when comparing control and pheromone-treated workers
  output <- data.frame(gene = SpliceCompare$gene[SpliceCompare$min < 1 & SpliceCompare$max > 1], stringsAsFactors = F)
  
  # Add the Apis mellifera ortholog, from one-way BLAST, if it's a non-Apis species
  if(species != "am"){
    orthologs <- tbl(my_db, paste(species, "2am", sep = "")) %>% select(-evalue) %>% collect(n=Inf) %>% as.data.frame()
    names(orthologs) <- c("gene", "Amel_ortholog")
    output <- left_join(output, orthologs, by = "gene") 
    output <- left_join(output, tbl(my_db, "bee_names") %>% 
                          rename(Amel_ortholog = gene), copy=T, by = "Amel_ortholog") 
  }
  else output <- left_join(output, tbl(my_db, "bee_names"), by = "gene", copy = T)
  
  output[is.na(output)] <- " "
  
  # Remove the 'isoform X' part from the gene name, so it gives the name of the gene not the isoform
  output$name <- unlist(lapply(strsplit(output$name, split = " isoform "), function(x) x[1]))
  
  output <- left_join(output, SpliceCompare, by = "gene") 
  
  output$min <- log2(output$min) # Log2 transform the fold changes
  output$max <- log2(output$max)
  output <- output %>% arrange(-(abs(min) + max)) # Arrange by effect size
  
  if(species == "am" | species == "bt") names(output) <- c("Gene", "Name", "Lowest FC", "Highest FC")
  else names(output) <- c("Gene", "Amel ortholog", "Name", "Lowest FC", "Highest FC")
  output
}
```

### Genes showing pheromone-induced alternative splicing in _A. mellifera_
**Table S`r numbering("supp.table.counter")`**: List of genes showing statistically significant pheromone-induced alternative splicing in _A. mellifera_. These genes were defined as those that have at least two isoforms that are differentially expressed following pheromone treatment with p < 10^-5^, and for which one isoform increases in expression while another decreases. The last two columns show the fold changes of the most down-regulated and most up-regulated isoforms, on a Log$_2$ scale.
```{r am.splice}
am.alt.splice <- find.alternatively.spliced.genes("am")
kable.table(am.alt.splice)
```

### Genes showing pheromone-induced alternative splicing in _L. flavus_
**Table S`r numbering("supp.table.counter")`**: List of genes showing statistically significant pheromone-induced alternative splicing in _L. flavus_. The table shows the same information as Table S10.
```{r lf.splice}
lf.alt.splice<- find.alternatively.spliced.genes("lf")
kable.table(lf.alt.splice)
```

### Genes showing pheromone-induced alternative splicing in _L. niger_
**Table S`r numbering("supp.table.counter")`**: List of genes showing statistically significant pheromone-induced alternative splicing in _L. niger_. The table shows the same information as Table S10.
```{r ln.splice}
ln.alt.splice <- find.alternatively.spliced.genes("ln")
kable.table(ln.alt.splice)
```

### There are no genes showing pheromone-sensitive splicing for _B. terrestris_
```{r bt.splice}
find.alternatively.spliced.genes("bt")  
```

### There is little overlap of specific pheromone-sensitive alternatively-spliced genes
```{r splice.venn}
lf.alt <- lf.alt.splice$Name[lf.alt.splice$Name != " "] # Exclude genes with no A. mellifera names
ln.alt <- ln.alt.splice$Name[ln.alt.splice$Name != " "]
venn(list(Apis = am.alt.splice$Name,`L. flavus` = lf.alt,`L. niger` = ln.alt))
```







## Gene co-expression network analysis

First, we define a series of functions for gene co-expression network analysis.
```{r network.functions}
# This function uses the ComBat function from the package 'sva' to remove variance in gene expression
# that is due to colony and species, allowing us to detect variance due to queen pheromone treatment.
# The use of ComBat in this fashion follows recommendations from the author of the WGCNA package. 
remove.effects.combat <- function(expression.data){
  sampleIDs <- rownames(expression.data)
  ids <- with(treatments[match(sampleIDs, treatments$id), ], 
              data.frame(
                id = sampleIDs,
                species = species,
                treatment = treatment,
                colony = paste(species, colony, sep = "")))
  
  modcombat <- model.matrix(~as.factor(treatment), data=ids)
  shh <- capture.output(expression.data <- ComBat(dat = t(expression.data), 
                                                  batch = ids$species, 
                                                  mod = modcombat, 
                                                  par.prior = TRUE))
  shh <- capture.output(expression.data <- t(ComBat(dat = expression.data, 
                                                    batch = ids$colony, 
                                                    mod = modcombat, 
                                                    par.prior = TRUE)))
  list(expression.data, ids)
}


# Build a gene coexpresison network using WGCNA package
build.network <- function(expression.data.list){
  # Pick the soft thresholding power that gives a model fit of R^2 > 0.8 for the scale-free topology model
  soft.power <- pickSoftThreshold(expression.data.list[[1]], 
                                  RsquaredCut = 0.8, verbose = 0, powerVector = 1:30)
  # Use this power to generate a gene co-expression network, using the default settings
  network <- blockwiseModules(expression.data.list[[1]], 
                              power = soft.power$powerEstimate,
                              networkType = "signed",
                              minModuleSize = 30,
                              verbose = 0,
                              saveTOMs = T)
  list(network, expression.data.list[[2]])
}


# By default, WGCNA gives the transcriptional modules random names like 'turqoise' or 'darkred'. 
# I think it's more helpful to define the biggest module as 'Module 1', the second biggest as 'Module 2', etc
# I use the label 'Module 0' for genes that were not assigned to a module
convert.module.colors.to.names <- function(network){
  module.sizes <- table(network[[1]]$colors) %>% sort %>% rev
  module.sizes <- c(module.sizes[names(module.sizes) == "grey"], 
                    module.sizes[names(module.sizes) != "grey"])
  module.mappings <- data.frame(color = names(module.sizes), 
                                new.name = paste("Module", 
                                                 0:(length(module.sizes)-1)), stringsAsFactors = F)
  network[[1]]$colors <- module.mappings$new.name[match(network[[1]]$colors, module.mappings$color)]
  names(network[[1]]$MEs) <- gsub("ME", "", names(network[[1]]$MEs))
  names(network[[1]]$MEs) <- module.mappings$new.name[match(names(network[[1]]$MEs), 
                                                            module.mappings$color)]
  network
}


# Rearrange the data in a handy format for stats and plotting, and remove the 'Module 0', the un-assigned genes
rearrange.eigengene.data <- function(network.list){
  cbind(network.list[[2]], network.list[[1]]$MEs) %>% 
    gather(Module, Eigengene, starts_with("Module")) %>% 
    filter(Module != "Module 0") %>%
    rename(Species = species, Treatment = treatment) %>% 
    arrange(Species, Treatment, colony, Module)
} 


# Run a model selection analysis on each module. The full linear model has eigengene as the response variable, and treatment, species and treatment:species as predictors. We rank the 5 possible models using their AIC scores, and test which provides the best fit to the data (the 'delta' and 'weight' parameters reveal the difference in explantory power)
run.stats <- function(dat){
  
  do.one.module <- function(module, dat){
    options(na.action = "na.fail") # need to set this option when running dredge()
    full.model <- lm(Eigengene ~ Treatment * Species, 
                     data = dat[dat$Module == paste("Module", module), ])
    output <- suppressMessages(dredge(full.model)) # compare full model and the four possible simpler models
    options(na.action = "na.omit") # set it back to default
    cbind(Module = module, output %>% as.data.frame()) # Add the module name to the results
  }
  
  stats <- do.call("rbind", # Run model selection on every module
                   lapply(1:length(unique(eigen.data$Module)), do.one.module, eigen.data))

  stats[,names(stats) %in% c("logLik", "AICc", "delta", "weight")] <- 
    format(round(stats[,names(stats) %in% c("logLik", "AICc", "delta", "weight")], 2), nsmall = 2) # rounding
  rownames(stats) <- NULL
  stats <- stats[,-2] # Remove the intercept column
  stats$Module[duplicated(stats$Module)] <- " "
  model <- rep("Null model")
  model[stats$Species == "+"] <- "~ Species"
  model[stats$Treatment == "+"] <- "~ Treatment"
  model[stats$Species == "+" & stats$Treatment == "+"] <- "~ Species + Treatment"
    model[stats$`Species:Treatment` == "+"] <- "~ Species x Treatment"
  model[is.na(model)] <- "Null model"
  stats <- with(stats, data.frame(Module, Model = model, 
                                  stats[,names(stats) %in% c("logLik", "AICc", "delta", "weight")]))
  stats
}
```

### Make the gene co-expression network, using the set of orthologous genes for all 4 species
```{r make.network, results="hide", warning=FALSE}
# The 4 bad samples get removed, then we find the orthologous genes, the data are scaled with ComBat, and then we build the network using the lowest soft-thresholding power that gives at least R^2 > 0.8 model fit
OGGs <- make.OGGs(c("am", "bt", "ln", "lf"), bad.samples = bad.samples)
network <- OGGs[[1]] %>%
  remove.effects.combat() %>% 
  build.network() %>%
  convert.module.colors.to.names()
eigen.data <- network %>% rearrange.eigengene.data
```

### Simple statistics about the network
Here is the number of orthologous genes that form the network:
```{r}
length(network[[1]]$colors)
```

Here is the number and size of modules in the network - module 0 refers to the unassigned genes.
```{r}
table(network[[1]]$colors) %>% pander
```


### Make a plot of the module eigengenes
```{r fig.width = 9, fig.height = 8}
# Make a plot of the module eigengenes, split by species, module and treatment
treatments.network.plot <- function(dat){ 
  dat %>% mutate(Treatment = replace(as.character(Treatment), Treatment == "QP", "Queen\npheromone")) %>%
    ggplot(aes(Species, Eigengene, fill = Treatment)) + 
    geom_hline(yintercept = 0, linetype=2) + 
    geom_boxplot() + 
    facet_wrap(~Module) + 
    xlab(NULL) + 
    scale_x_discrete(labels = c("Apis\nmellifera", "Bombus\nterrestris", "Lasius\nflavus", "Lasius\nniger")) +
    scale_fill_brewer(name = " ", palette = "Set3", direction = -1) + 
    theme_bw() + 
    theme(strip.background = element_blank(), 
          axis.text.x = element_text(face = "italic"), 
          panel.border = element_rect(size=0.7), 
          legend.position = "top") 
}

eigen.data %>% treatments.network.plot()
ggsave(eigen.data %>% treatments.network.plot(), 
       file = "figures/Module eigengenes.pdf", height = 6.6, width = 8)
```
 <br/><br/> 
 **Figure 4**: The figure shows the distribution of module eigengenes for each combination of module, species, and queen pheromone (QP) treatment. Positive values mean that the focal group has higher eigengenes, which derived from the relative expression levels of a module of genes, than the average. 



### Run model selection analysis to test for treatment and species effects on eigengenes

**Table S13**: Model selection analysis, using AICc (corrected Akaike Information Criterion) to rank all possible models of the module eigengene data shown in Figure S5. The models are listed from best to worst for each module. The 'delta' column gives the difference in AICc scores between the focal model and the top model in the set, where delta > 2 is considered to be a significant improvement in model fit. The column 'weight' gives Akaike weights, which can be interpreted as probabilities that the focal model is the top model in the set, given the data.
```{r}
run.stats(eigen.data) %>% kable.table()
```

### Plot the correlations between all modules and the pheromone treatment
```{r, fig.width = 6, fig.height=6}
meta.module.plot <- function(network){
 
  MET <- network[[1]]$MEs 
  MET <- data.frame(QP = (network[[2]]$treatment %>% as.numeric())-1, MET) %>% dplyr::select(-Module.0)
  names(MET) <- gsub("[.]", " ", names(MET))
  cluster <- (1 - cor(MET)) %>% as.dist() %>% hclust()
  ordering <- cluster$labels[cluster$order]
  heat.map.data <- cor(MET) %>% melt %>% 
    mutate(Var1 = factor(Var1, levels = ordering),
           Var2 = factor(Var2, levels = ordering)) %>% 
    rename(Corr = value)
  heat.map <- heat.map.data %>% ggplot(aes(Var1, Var2, fill = Corr)) + geom_tile() + 
    scale_fill_gradient2(low = brewer.pal(9, "RdBu")[8], 
                         mid = "white", 
                         high = brewer.pal(9, "RdBu")[2]) + 
    xlab(NULL) + ylab(NULL) + 
    theme_bw() + 
    theme(panel.border = element_blank(), 
          panel.grid = element_blank()) + 
    scale_x_discrete(expand = c(0,0)) + 
    scale_y_discrete(expand = c(0,0))
 
  dendrogram <- ggdendrogram(cluster) + theme(axis.text.x = element_blank(), axis.text.y = element_blank())
  
  p1 <- grid.arrange(dendrogram, heat.map)
  invisible(p1)
}

meta.plot <- meta.module.plot(network)
ggsave(meta.plot, file = "figures/meta_module_heat_map.pdf", width = 5, height = 7.3, units = "in")
meta.plot
```
 <br/><br/> 
 **Figure S`r numbering("supp.figure.counter")`**: Dendrogram and heat map showing the correlations among module eigengene values and the queen pheromone treatment (QP; coded as zero and 1 for the control and treatment respectively). Modules with red colour, or which are close on the dendrogram, show more correlated expression. The queen pheromone treatment was correlated with Module 5, but was relatively uncorrelated with the other modules.


**Table S`r numbering("supp.table.counter")`**: Results of Spearman's rank correlations testing for a relationship between the effect of queen pheromone on gene expression, and the connectedness of the gene. Negative values of Spearman's Rho mean that highly pheromone-sensitive genes tend to have lower connectedness.
```{r connectedness, warnings = FALSE} 
load("blockwiseTOM-block.1.RData") # Load the TOM from the network analysis - can be used to find connectedness for each ortholog

# Get the phermonone sensitivity value for each of the OGGs, and line it up with the connectedness data
suppressMessages(dd <- OGGs[[2]] %>% left_join(tbl(my_db, "ebseq_gene_am") %>% select(gene, PostFC) %>% rename(am=gene), copy=T) %>% rename(am_FC = PostFC) %>%
  left_join(tbl(my_db, "ebseq_gene_bt") %>% select(gene, PostFC) %>% 
              rename(bt=gene), copy=T) %>% rename(bt_FC = PostFC) %>%
  left_join(tbl(my_db, "ebseq_gene_lf") %>% select(gene, PostFC) %>% 
              rename(lf=gene), copy=T) %>% rename(lf_FC = PostFC) %>%
  left_join(tbl(my_db, "ebseq_gene_ln") %>% select(gene, PostFC) %>% 
              rename(ln=gene), copy=T) %>% rename(ln_FC = PostFC) %>%
  mutate(k = colSums(as.matrix(TOM))))

do.spearman <- function(dd, species, name){ # run spearman on each species
  test <- cor.test(dd$k, dd[, names(dd) == species] %>% log2 %>% abs, method = "spearman")  # Note that we convert the fold-change in expression with abs(log2(x)), to get pheromone sensitivity
  with(test, data.frame(Species = name, rho = estimate, p = p.value, row.names = NULL))
}

suppressWarnings(results <- rbind(do.spearman(dd, "am_FC", "Apis mellifera"),
                                  do.spearman(dd, "bt_FC", "Bombus terrestris"),
                                  do.spearman(dd, "lf_FC", "Lasius flavus"),
                                  do.spearman(dd, "ln_FC", "Lasius niger")))
rownames(results) <- NULL
pander(results)
```


## Characteristics of pheromone-sensitive genes in _Apis_
In this section, we search for correlates of the absolute Log_2 fold change in response to pheromone (where positive values denote genes whose expression differs strongly between the control and pheromone treatment). This section makes use of data kindly provided by Soojin Yi and Brendan Hunt.

The data on queen and worker-specific gene expression come from Grozinger et al. 2007. We found that pheromone-sensitive genes tend to be over-expressed by queens relative to sterile workers. However, genes that are over-expressed by fertile workers relative to sterile workers did not tend to be more (or less) pheromone-sensitive. 

The methylation level (i.e. % methylated cytosines) data come from Galbraith et al. 2016 (provided by Soojin Yi). We found a negative correlation between methylation and pheromone-sensitivity, suggesting that pheromone-sensitive genes are hypomethylated. 

The CpG O/E values were calculated for the latest _A. mellifera_ genome annotation. We found a positive correlation between CpG O/E and pheromone-sensitivity. High CpG is associated with lower rate of DNA methylation, again suggesting that pheromone-sensitive genes are hypomethylated. 

The estimates of $\gamma$, a measure of positive and negative selection similar to dN/dS, come from Harpur et al. 2014 PNAS. There was a significant positive correlation between $\gamma$ and sensitivity to queen pheromone, suggesting that highly pheromone-sensitive genes tend to be positively selected.

The Codon adaptation index was calculated by Brendan Hunt. A high codon adaptation index denotes high codon usage bias, i.e. where certain synonymous codons are more common than others. Pheromone-sensitive genes showed low codon usage bias.

Lastly, 'expression level' refers to the average expression of each gene, expressed as TPM (transcripts per million) as measured by the software RSEM in the present study. Highly expressed genes tended to be less pheromone-sensitive.

```{r fig.height=8, fig.width=8}
# import and clean up the data provided by Brendan Hunt
hunt.data <- read.delim("data/apis_gene_comparisons/Amel_AllData_012709.txt", 
                        header=T, stringsAsFactors = FALSE) %>% 
  mutate(log2RW.SW = log2(RW_bagel / SW_bagel))        # calculate log fold difference in gene expression between fertile and sterile workers
entrez.tbl <- read.delim("data/apis_gene_comparisons/am.gene_info.txt", stringsAsFactors = FALSE)[,c(2,5,6)] # import table of gene names (Entrez, old Beebase, and new Beebase)
names(entrez.tbl) <- c("entrez.id", "beebase1", "beebase2")
hunt.data <- hunt.data %>% 
  dplyr::select(ID, log2Q.SW, log2RW.SW, CAI, cpgOE) %>% # get gene ID and the relevant data
  rename(beebase1 = ID) %>%                              # merge based on beebase IDs
  left_join(entrez.tbl, by = "beebase1") %>% 
  filter(!is.na(beebase2) & beebase2 != "-") %>% 
  mutate(beebase2 = gsub("BEEBASE:", "", beebase2)) %>% 
  rename(gene = beebase2) %>% 
  dplyr::select(gene, log2Q.SW, log2RW.SW, CAI, cpgOE)
hunt.data <- left_join(tbl(my_db, "ebseq_gene_am") %>%       # merge Hunt's data with our phermone sensitivity data
                         dplyr::select(gene, PostFC) %>% collect(), hunt.data, by = "gene") %>% 
  left_join(tbl(my_db, "bee_names") %>% collect, by = "gene")  # also add the gene names 

# Import methylation data provided by Soojin Yi and Xin Wu (from Galbraith et al PNAS)
methylation <- read.csv("data/apis_gene_comparisons/apis_gene_methyl_CG_OE.csv", stringsAsFactors = FALSE)
methylation <- tbl(my_db, "ebseq_gene_am") %>% collect %>% left_join(methylation, by = "gene") %>%
  filter(!is.na(Gene_body_methylation)) %>%
  left_join(tbl(my_db, "bee_names") %>% collect(), by = "gene") %>% distinct(gene, .keep_all = T)

# Import gamma data from Harpur et al PNAS
gamma_am <- tbl(my_db, "ebseq_gene_am") %>% collect() %>%
  left_join(read.table("data/apis_gene_comparisons/harpur_etal_gamma.txt", header=TRUE, stringsAsFactors=FALSE) %>% rename(gene = Gene), by = "gene") %>%
  filter(!is.na(gamma)) %>%
  dplyr::select(gene, PostFC, gamma) %>%
  mutate(PostFC = log2(PostFC)) %>% left_join(tbl(my_db, "bee_names"), copy=TRUE, by = "gene") %>%
  arrange(-abs(PostFC))


merged <- hunt.data %>% dplyr::select(gene, PostFC, log2Q.SW, log2RW.SW, CAI) %>% 
  left_join(methylation %>% dplyr::select(gene, CG_OE, Gene_body_methylation), by = "gene") %>% # merge in methylation data provided by Soojin Yi
  left_join(gamma_am %>% dplyr::select(gene, gamma), by = "gene") %>%                         # merge in gamma data from Harpur et al
  left_join(data.frame(gene = tbl(my_db, "rsem_am") %>% 
                         dplyr::select(gene) %>% collect(),  # calculate overall expression level from our own data
                       expression.level = (tbl(my_db, "rsem_am") %>% 
                                             dplyr::select(-gene) %>% 
                                             collect %>% rowSums())), by = "gene") %>% 
  left_join(dd %>% dplyr::select(am, k) %>% rename(gene=am), by = "gene") %>%
  dplyr::select(-gene) %>% 
  mutate(CG_OE = -log2(CG_OE),                         # log2 CpG O/E ratio - change the sign, so that high values mean high methylation
         expression.level = log10(expression.level),   # log10 the expression level
         PostFC = abs(log2(PostFC))) %>%               # absolute log2 fold-change in response to pheromones (i.e. 'pheromone sensitivity' score)
  as.data.frame() 

m.rename <- function(merged, col, new) {names(merged)[names(merged) == col] <- new; merged}
merged <- merged %>% m.rename("PostFC", "Pheromone sensitivity\n(absolute log fold)")   # re-label all the variables nicely
merged <- merged %>% m.rename("log2Q.SW", "Upregulation in queens\n(log fold)")
merged <- merged %>% m.rename("log2RW.SW", "Upregulation in fertile\nworkers (log fold)")
merged <- merged %>% m.rename("CAI", "Codon usage bias\n(CAI)")
merged <- merged %>% m.rename("CG_OE", "DNA methylation\n(CpG depletion)")
merged <- merged %>% m.rename("Gene_body_methylation", "DNA methylation\n(BiS-seq)")
merged <- merged %>% m.rename("gamma", "Positive selection\n(Gamma)")
merged <- merged %>% m.rename("expression.level", "Log Expression level")
merged <- merged %>% m.rename("k", "Connectivity in the\ntranscriptome")

reorder_cormat <- function(cormat){ # reorder a correlation matrix using hierarchical clustering
  dd <- as.dist((1-cormat)/2)
  hc <- hclust(dd)
  cormat[hc$order, hc$order]}

cormat <- reorder_cormat(cor(merged, use = 'pairwise.complete.obs'))
cormat[upper.tri(cormat)] <- NA
diag(cormat) <- NA

cor.matrix <-  (melt(cormat) %>% filter(!is.na(value)))[,1:2] %>% mutate(cor=0,p=0) 
for(i in 1:nrow(cor.matrix)) cor.matrix[i, 3:4] <- cor.test(merged[, names(merged) == cor.matrix$Var1[i]], merged[, names(merged) == cor.matrix$Var2[i]])[c(4,3)] %>% unlist
cor.matrix$p <- p.adjust(cor.matrix$p, method = "BH") # apply B-H p value correction
cor.matrix$sig <- ""
cor.matrix$sig[cor.matrix$p < 0.05] <- "*"   
cor.matrix$sig[cor.matrix$p < 0.001] <- "**"  
cor.matrix$sig[cor.matrix$p < 0.0001] <- "***"   
cor.matrix$label <- paste(format(round(cor.matrix$cor,2), nSmall =2), cor.matrix$sig)
correlation.plot <- cor.matrix %>% 
  ggplot(aes(Var1, Var2, fill=cor)) + 
  geom_tile(colour="grey10",alpha=0.7) + 
  scale_fill_gradient2(name = "Corr", 
                       low = brewer.pal(9, "RdYlBu")[7], 
                       mid = "white", 
                       high = brewer.pal(9, "RdYlBu")[2]) +
  geom_text(aes(label = label), colour = "grey25", size = 3.5) + 
  xlab(NULL) + ylab(NULL) +
  scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0, 0)) + 
  theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1, face = c("bold", rep("plain", 5), "bold", "plain")), 
                          axis.text.y = element_text(face = c("plain", "bold", rep("plain", 5), "bold")), 
                          panel.grid = element_blank(), 
                          legend.position = "none") 
ggsave(correlation.plot, file = "figures/correlation_plot.pdf", width =8, height = 8)
correlation.plot
```
 <br/><br/> 
**Figure 5**: Correlations across genes between various parameters, for _Apis mellifera_. 'Pheromone sensitivity' was calculated as the absolute value of the Log$_2$ fold difference in expression between pheromone treatment and the control. The Log FC (fold change) data come from Grozinger et al. 2007 (Mol. Ecol.), and positive values denote genes that have higher expression in queens or fertile workers, relative to sterile workers. Codon usage bias was estimated by the codon adaptation index: high values indicate bias for particular synonymous codons. DNA methylation rate was estimated either by the frequency of CpGs (i.e. -log CpG O/E ratio), or from bisulphite sequencing (BiS-seq). The parameter gamma ($\gamma$) describes the form of selection, where positive values denote positive selection, and negative values purifying selection. Lastly, the expression level was calculated from our own dataset as the log transcripts per million, averaged across our 6 _Apis_ libraries.


## Contrasting our _Lasius_ data with results from Morandin _et al._ 2016

Morandin _et al._ 2016 (_Genome Biology_ 17:43) studied whole transcriptomes from queens and workers in 16 diverse ant species, including two other species from the genus _Lasius_. Using BLAST, they grouped genes into OGGs (orthologous gene groups), and built a co-expression network using all the OGGs that were common to all 16 species (similar to the present study). Their analysis yielded 36 modules, of which many showed significant queen-worker differences in their module eigengenes. Here, we want to test whether these queen- and worker-like modules significantly overlap with the pheromone-sensitive modules in the present study.

To do this, we used BLAST to identify orthologous gens in _L. niger_ and _L. flavus_ that belong to one of Morandin et al.'s OGGs. We then tested for significantly-greater-than-random overlap between Morandin et al's modules, and our own study's modules, using hypergeometric tests. 

Of all the possible module pairs, we found 6 pairs that overlapped significantly more than expected (FDR-corrected). One of these pairs included our highly pheromone-sensitive module, Module 4, which overlapped with the caste-biased Module 13 from Morandin et al. The intersecting genes include _protein take-out like_, a NAD kinase 2, a serine protease, and _histone H2A-like_.


**Table S`r numbering("supp.table.counter")`**: A list of the six module pairs, from Morandin _et al._ 2016 and the present study, which had significantly more genes in common than expected by chance. The p-values were calculated by running hypergeometric tests on all possible pairs of modules from the two studies, and then adjusting all the p-values using the Benjamini-Hochberg procedure. 
```{r morandin, warning=FALSE, message=FALSE}
morandin.orthology <- read.csv("data/morandin_comparison_data/Morandin to Holman orthology.csv", stringsAsFactors = FALSE)
morandin.module.membership <- read.csv("data/morandin_comparison_data/Morandin module membership.csv", stringsAsFactors = FALSE)
morandin.module.caste.bias <- read.csv("data/morandin_comparison_data/Morandin module caste bias.csv", stringsAsFactors = FALSE)
# Create list of all the L. niger & L. flavus genes are are part of
# the Orthologous Gene Groups (OGGs) from Morandin et al.
# Here are the 3634 genes for which we have 1-to-1 orthologs in all 18 species:
morandin.oggs <- make.OGGs(c("ln", "lf"))[[2]] %>% 
  left_join(morandin.orthology, by = "ln") %>%
  filter(!is.na(morandin.ogg)) %>% 
  left_join(morandin.module.membership, by = "morandin.ogg") %>%
  left_join(tbl(my_db, "ln2am") %>% 
              left_join(tbl(my_db, "bee_names"), by = c("am" = "gene")) %>%
              filter(!is.na(name)) %>% select(ln, name, am) %>% 
              rename(apis.name = name) %>% collect(n=Inf), by = "ln") %>%
  left_join(morandin.module.caste.bias, by = "module") %>%
  rename(morandin.module = module) %>%
  left_join(data.frame(ln = OGGs[[2]]$ln, 
                       holman.module = network[[1]]$colors, 
                       stringsAsFactors = F), by = "ln") %>%
  left_join(tbl(my_db, "ebseq_gene_ln") %>% 
              select(gene, PostFC) %>% collect(n=Inf) %>% rename(ln = gene), by = "ln") %>%
  rename(FC.pheromone = PostFC)
overlaps <- table(morandin.oggs$morandin.module, 
                  morandin.oggs$holman.module) %>% 
  melt() %>% rename(morandin.module = Var1, 
                    holman.module = Var2, 
                    overlaps = value) %>%
  filter(holman.module != "Module 0") %>%
  left_join(table(morandin.oggs$morandin.module) %>% 
              melt() %>% rename(mor.mod.size = value), 
            by = c("morandin.module" = "Var1")) %>% 
  left_join(table(morandin.oggs$holman.module) %>% melt() %>% 
              rename(hol.mod.size = value), by = c("holman.module" = "Var1"))

# List all the Morandin et al. modules that significantly overlap with our own modules
overlaps <- data.frame(
  overlaps, 
  do.call("rbind", 
          lapply(1:nrow(overlaps), 
                 function(i) with(overlaps, 
                                  overlap.hypergeometric.test(
                                    overlaps[i], 
                                    mor.mod.size[i], 
                                    hol.mod.size[i], 
                                    nrow(morandin.oggs), 
                                    species = "xx"))))[,2:3]) %>% 
  filter(Test == "Overlap is higher than expected:") %>% 
  arrange(p) %>% select(-Test) %>% 
  left_join(morandin.oggs %>% 
              select(morandin.module, caste.bias) %>% 
              distinct(), by = "morandin.module") %>% 
  mutate(p = p.adjust(p, method = "BH"),
         morandin.module = paste("Module", morandin.module)) %>%
  filter(p < 0.05) 
names(overlaps) <- c("Morandin module", "Holman module", "n overlapping genes", "Size of Morandin module", "Size of Holman module", "p-value", "Caste bias of Morandin module")
overlaps %>% 
  pander(split.cell = 40, split.table = Inf)
```

A list of the genes (OGGs) that appear in the present study's Module 4 (which is pheromone-sensitive), and also in Morandin et al.'s Module 13 (which is caste-biased).
```{r}
morandin.oggs %>% 
  filter(morandin.module == 13, holman.module == "Module 4") %>% 
  .$apis.name
```

 

## KEGG and GO enrichment for differentially _expressed_ genes
First, define some functions we will need. See also the R script "Script to set up for GO analyses.R", which was used to make the object gene_set_collection.RData, following instructions for making a GO annotation for a non-model organism at http://bioconductor.org/packages/2.11/bioc/vignettes/GOstats/inst/doc/GOstatsForUnsupportedOrganisms.pdf.

There are only two differentially expressed genes for _B. terrestris_, so it is only meaningful to test for enriched GO/KEGG terms in the other three species.
```{r module.funs, warnings = FALSE}
GO.and.KEGG.enrichment <- function(enriched.genes, gene.universe, ontology, pan = TRUE, keep.all = FALSE){
  
  p <- 0.05
  neatness <- function(x, dp) format(round(x, dp), nsmall = 3)
  if(keep.all) p <- 1
  GO.enrichment <- function(enriched.genes, gene.universe, ontology){
    
    params <- GSEAGOHyperGParams(
      name = "Luke's Params",
      geneSetCollection = gene_set_collection, # custom GO annotations 
      geneIds = enriched.genes,
      universeGeneIds = gene.universe,
      ontology = ontology, # Can be BP, MF, or CC
      pvalueCutoff = p,
      conditional = TRUE, # Do the test conditional on the GO structure
      testDirection = "over") # Look for over-represented GO terms, not under
    
    hyperGTest(params) %>%
      summary() %>% 
      dplyr::mutate(Pvalue = neatness(Pvalue, 5),
                    OddsRatio = neatness(OddsRatio, 3),
                    ExpCount = neatness(ExpCount, 3)) %>%
      dplyr::rename(ID = GOBPID)
  }
  
  kegg.enrichment <- function(enriched.genes, gene.universe){
    
    params <- GSEAKEGGHyperGParams(
      name = "Luke's Params",
      geneSetCollection = gene_set_collection_kegg, # custom KEGG annotations 
      geneIds = enriched.genes,
      universeGeneIds = gene.universe,
      pvalueCutoff = p,
      testDirection = "over") # Look for over-represented KEGG terms, not under
    
    hyperGTest(params) %>% 
      summary() %>% 
      dplyr::mutate(Pvalue = neatness(Pvalue, 5),
                    OddsRatio = neatness(OddsRatio, 3),
                    ExpCount = neatness(ExpCount, 3),
                    KEGGID = paste("KEGG", KEGGID, sep = ":")) %>%
      dplyr::rename(ID = KEGGID)
  }
  
  output <- rbind(kegg.enrichment(enriched.genes, gene.universe), 
                  GO.enrichment(enriched.genes, gene.universe, ontology)) 
  if(!pan) return(output)
  output %>% kable.table()
}

# Find the names for the genes in a given module
genes.in.module <- function(module.number){
  colnames(OGGs[[1]])[network[[1]]$colors == paste("Module", module.number)]
}

# Get the gene names, and sensitivity to pheromone, for genes in a certain module
inspect.module.genes <- function(module){
  gene.names <- tbl(my_db, "bee_names") %>% as.data.frame()
  gene.names <- gene.names[gene.names$gene %in% genes.in.module(module), ]
  gene.names$k <- colSums(as.matrix(TOM)[network[[1]]$colors == paste("Module", module), 
                                        network[[1]]$colors == paste("Module", module)])
  gene.names <- gene.names %>% arrange(-k)
  
  am <- tbl(my_db, "ebseq_gene_am") %>% as.data.frame()
  gene.names$am_fc <- am$PostFC[match(gene.names$gene, am$gene)]
  bt <- tbl(my_db, "ebseq_gene_bt") %>% rename(bt = gene) %>% 
    left_join(tbl(my_db, "bt2am")) %>% as.data.frame()
  gene.names$bt_fc <- bt$PostFC[match(gene.names$gene, bt$am)]
  lf <- tbl(my_db, "ebseq_gene_lf") %>% rename(lf = gene) %>% 
    left_join(tbl(my_db, "lf2am")) %>% as.data.frame()
  gene.names$lf_fc <- lf$PostFC[match(gene.names$gene, lf$am)]
  ln <- tbl(my_db, "ebseq_gene_ln") %>% rename(ln = gene) %>% 
    left_join(tbl(my_db, "ln2am")) %>% as.data.frame()
  gene.names$ln_fc <- ln$PostFC[match(gene.names$gene, ln$am)]
  row.names(gene.names) <- NULL
  gene.names
}

# Load the gene set collection object needed for the GO tests
load("data/gene_set_collection.RData")

# Load the gene set collection object needed for the KEGG tests
load("data/gene_set_collection_kegg.RData")
```


### KEGG and GO enrichment for differentially expressed genes in _A. mellifera_
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes that were significantly upregulated in the **control** group in _A. mellifera_. The gene universe was defined as all _A. mellifera_ genes measured in this study.
```{r apis.up.exp.go, showWarnings = FALSE}
gene.universe.apis <- (tbl(my_db, "rsem_am") %>% 
                         as.data.frame())$gene
up.in.control.apis <- (apis.de %>% filter(`Log2 FC` > 0) %>% as.data.frame())$Gene
suppressMessages(GO.and.KEGG.enrichment(up.in.control.apis, gene.universe.apis, ontology = "BP"))
```

 <br/><br/> 
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes that were significantly upregulated in the **queen pheromone** treatment in _A. mellifera_. The gene universe was defined as all _A. mellifera_ genes measured in this study.
```{r apis.down.exp.go, showWarnings = FALSE}
up.in.QP.apis <- (apis.de %>% filter(`Log2 FC` < 0) %>% as.data.frame())$Gene
GO.and.KEGG.enrichment(up.in.QP.apis, gene.universe.apis, ontology = "BP") 
```



### KEGG and GO enrichment for differentially expressed genes in _L. flavus_
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes that were significantly upregulated in the **control** group in _L. flavus_. The gene universe was defined as all _L. flavus_ genes for which we detected an _A. mellifera_ ortholog.
```{r flavus.up.exp.go}
# The gene universe is all L. flavus genes for which we found a BLAST hit in Apis mellifera
gene.universe.flavus <- (left_join(tbl(my_db, "rsem_lf") %>% 
                                     dplyr::select(gene),  
                                   tbl(my_db, "lf2am") %>% 
                                     dplyr::rename(gene = lf), by = "gene") %>% 
                           dplyr::select(am) %>% 
                           filter(!is.na(am)) %>% 
                           as.data.frame())[,1] %>% unique
# The test set is all differentially expressed genes in L. flavus for which we found a BLAST hit in Apis
up.in.control.flavus <- (flavus.de %>% filter(`Log2 FC` > 0 & `Apis BLAST` != " ") %>% as.data.frame())$`Apis BLAST` %>% unique

GO.and.KEGG.enrichment(up.in.control.flavus, gene.universe.flavus, ontology = "BP")
```

 <br/><br/> 
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes that were significantly upregulated in the **queen pheromone** treatment in _L. flavus_. The gene universe was defined as all _L. flavus_ genes for which we detected an _A. mellifera_ ortholog.
```{r flavus.down.exp.go}
up.in.QP.flavus <- (flavus.de %>% filter(`Log2 FC` < 0 & `Apis BLAST` != " ") %>% as.data.frame())$`Apis BLAST` %>% unique
GO.and.KEGG.enrichment(up.in.QP.flavus, gene.universe.flavus, ontology = "BP") 
```


### KEGG and GO enrichment for differentially expressed genes in _L. niger_
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes that were significantly upregulated in the **control** group in _L. niger_ The gene universe was defined as all _L. niger_ genes for which we detected an _A. mellifera_ ortholog.
```{r niger.up.exp.go}
# The gene universe is all L. flavus genes for which we found a BLAST hit in Apis mellifera
gene.universe.niger <- (left_join(tbl(my_db, "rsem_ln") %>% 
                                    dplyr::select(gene), 
                                  tbl(my_db, "ln2am") %>%  
                                    dplyr::rename(gene = ln), by = "gene") %>% 
                          dplyr::select(am) %>% 
                          filter(!is.na(am)) %>% 
                          as.data.frame())[,1] %>% unique
# The test set is all differentially expressed genes in L. flavus for which we found a BLAST hit in Apis
up.in.control.niger <- (niger.de %>% filter(`Log2 FC` > 0 & `Apis BLAST` != " ") %>% as.data.frame())$`Apis BLAST` %>% unique

GO.and.KEGG.enrichment(up.in.control.niger, gene.universe.niger, ontology = "BP") 
```

 <br/><br/> 
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes that were significantly upregulated in the **queen pheromone** treatment in _L. niger_ The gene universe was defined as all _L. niger_ genes for which we detected an _A. mellifera_ ortholog.
```{r niger.down.exp.go}
up.in.QP.niger <- (niger.de %>% filter(`Log2 FC` < 0 & `Apis BLAST` != " ") %>% as.data.frame())$`Apis BLAST` %>% unique
GO.and.KEGG.enrichment(up.in.QP.niger, gene.universe.niger, ontology = "BP")  
```


### KEGG and GO enrichment for differentially expressed genes observed in multiple species
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes showing significant differential expression in response to queen pheromone in two or more species. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r overlap.go, messages=FALSE}
overlap.gene.universe <- make.OGGs(c("am", "lf", "ln"))[[2]]$am      # The gene universe is all genes that have orthologs in the 3 species that we tested for overlap
suppressWarnings(GO.and.KEGG.enrichment(all.overlaps, overlap.gene.universe, ontology = "BP")) 
```


## KEGG and GO enrichment for differentially spliced genes

### KEGG and GO enrichment for _A. mellifera_ genes showing pheromone-modulated alternative splicing
```{r apis.spl.go}
# The gene universe is defined as all genes that have 2 or more isoforms. It would be anti-conservative if we instead included all genes, not just that are alternatively spliced
gene.universe.apis.splicing <- (tbl(my_db, "isoforms_am") %>% 
                                  group_by(gene) %>% 
                                  summarise(nIsoforms = n()) %>% filter(nIsoforms > 1) %>% 
                                  as.data.frame() %>% 
                                  dplyr::select(gene) %>% as.data.frame())[,1]
```

**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes showing significant alternative splicing in _A. mellifera_. The gene universe was defined as all genes that showed alternative splicing in _A. mellifera_.
```{r apis.go}
GO.and.KEGG.enrichment(am.alt.splice$Gene, gene.universe.apis.splicing, ontology = "BP") 
```

### KEGG and GO enrichment for _L. flavus_ genes showing pheromone-modulated alternative splicing
```{r flavus.spl.go}
# For flavus and niger, we additionally have to find the best BLAST Apis genes when constructing the gene lists
gene.universe.flavus.splicing <- (tbl(my_db, "isoforms_lf") %>% 
                                  group_by(gene) %>% 
                                  summarise(nIsoforms = n()) %>% filter(nIsoforms > 1) %>% 
                                  as.data.frame() %>% 
                                  dplyr::select(gene) %>% as.data.frame())[,1]

gene.universe.flavus.splicing <- (tbl(my_db, "lf2am") %>%  # Convert to Apis gene names via BLAST
                         filter(lf %in% gene.universe.flavus.splicing) %>% 
                         dplyr::select(am) %>% filter(!is.na(am)) %>% as.data.frame())[,1]

alt.spliced.flavus <- (tbl(my_db, "lf2am") %>% 
                         filter(lf %in% lf.alt.splice$Gene) %>% 
                         dplyr::select(am) %>% filter(!is.na(am)) %>% as.data.frame())[,1]
```

**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes showing significant alternative splicing in _L. flavus_. The gene universe was defined as all genes that showed alternative splicing in _L. flavus_, which also had a known ortholog in _A. mellifera_.
```{r}
GO.and.KEGG.enrichment(alt.spliced.flavus, gene.universe.flavus, ontology = "BP")
```

### KEGG and GO enrichment for _L. niger_ genes showing pheromone-modulated alternative splicing
```{r niger.spl.go}
gene.universe.niger.splicing <- (tbl(my_db, "isoforms_ln") %>% 
                                  group_by(gene) %>% 
                                  summarise(nIsoforms = n()) %>% filter(nIsoforms > 1) %>% 
                                  as.data.frame() %>% 
                                  dplyr::select(gene) %>% as.data.frame())[,1]

gene.universe.niger.splicing <- (tbl(my_db, "ln2am") %>%  # Convert to Apis gene names via BLAST
                         filter(ln %in% gene.universe.niger.splicing) %>% 
                         dplyr::select(am) %>% filter(!is.na(am)) %>% as.data.frame())[,1] %>%
  unique

alt.spliced.niger <- (tbl(my_db, "ln2am") %>% 
                        filter(ln %in% ln.alt.splice$Gene) %>% 
                        dplyr::select(am)%>% filter(!is.na(am)) %>% as.data.frame())[,1]
```

**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis on the list of genes showing significant alternative splicing in _L. niger_. The gene universe was defined as all genes that showed alternative splicing in _L. niger_, which also had a known ortholog in _A. mellifera_.
```{r}
GO.and.KEGG.enrichment(alt.spliced.niger, gene.universe.niger.splicing, ontology = "BP") 
```

## Figures summarising KEGG and GO results
These two figures help to see which KEGG and GO terms showed up more than once, and to compare _Apis_ and the two _Lasius_ species.
```{r}
# First, look for enriched KEGG and GO terms in all the DE gene and isoform lists jsut as before, but this time return all the results (keep.all = TRUE)
big.table <- rbind(suppressMessages(
  GO.and.KEGG.enrichment(up.in.control.apis, gene.universe.apis, ontology = "BP", pan = FALSE, keep.all = TRUE) ) %>% 
    mutate(species = "A. mellifera", type = "Up in control"),
  GO.and.KEGG.enrichment(up.in.QP.apis, gene.universe.apis, ontology = "BP", pan = FALSE, keep.all = TRUE) %>% 
    mutate(species = "A. mellifera", type = "Up in QP"),
  GO.and.KEGG.enrichment(up.in.control.flavus, gene.universe.flavus, ontology = "BP", pan = FALSE, keep.all = TRUE) %>% 
    mutate(species = "L. flavus", type = "Up in control"),
  GO.and.KEGG.enrichment(up.in.QP.flavus, gene.universe.flavus, ontology = "BP", pan = FALSE, keep.all = TRUE) %>% 
    mutate(species = "L. flavus", type = "Up in QP"),
  GO.and.KEGG.enrichment(up.in.control.niger, gene.universe.niger, ontology = "BP", pan = FALSE, keep.all = TRUE) %>% 
    mutate(species = "L. niger", type = "Up in control"),
  GO.and.KEGG.enrichment(up.in.QP.niger, gene.universe.niger, ontology = "BP", pan = FALSE, keep.all = TRUE) %>% 
    mutate(species = "L. niger", type = "Up in QP"),
  GO.and.KEGG.enrichment(am.alt.splice$Gene, gene.universe.apis.splicing, ontology = "BP", pan = FALSE, keep.all = TRUE) %>% 
    mutate(species = "A. mellifera", type = "Splicing"),
  GO.and.KEGG.enrichment(alt.spliced.flavus, gene.universe.flavus, ontology = "BP", pan = FALSE, keep.all = TRUE) %>% 
    mutate(species = "L. flavus", type = "Splicing"),
  GO.and.KEGG.enrichment(alt.spliced.niger, gene.universe.niger.splicing, ontology = "BP", pan = FALSE, keep.all = TRUE) %>% 
    mutate(species = "L. niger", type = "Splicing"))

# This line means that GO/KEGG categories which did not even appear in the list of enriched genes get a p value of 1 
plot.data <- expand.grid(ID = unique(big.table$ID), 
                         species = unique(big.table$species), 
                         type = unique(big.table$type), stringsAsFactors = FALSE) %>% 
  left_join(big.table %>% dplyr::select(ID, type, species, Pvalue), by = c("ID", "species", "type")) %>% 
  mutate(Pvalue = as.numeric(as.character(replace(Pvalue, is.na(Pvalue), 1)))) 
```

### Summary figure of KEGG results
**Figure 2**: A summary of the KEGG enrichment tests: KEGG terms with multiple red squares were significantly enriched in multiple tests. Each square shows one of three results, for one of three species, and the colour of the square indicates the p-value for that result (on a -log10 scale) - blue squares are not statistically significant, red squares are significant (and are also marked with asterisks), and white squares are close to the p = 0.05 threshold. The "Up in QP" rows show the results of enrichment tests for KEGG terms on the gene set that was significantly up-regulated in queen pheromone-treated workers. The "Up in control" row shows the same tests, on the gene set that was significantly up-regulated in control workers. The "Splicing" row shows the results of the same tests, on the gene set that showed a significant change in alterative splicing between the two treatments.
```{r fig.width = 11, fig.height = 12}
kegg.plot.data <- plot.data %>% filter(grepl("KEGG", ID))
kegg.plot.data <- kegg.plot.data[kegg.plot.data$ID %in% (kegg.plot.data %>% 
                                            group_by(ID) %>% 
                                            summarise(min.p = min(Pvalue)) %>% 
                                            filter(min.p < 0.05) %>% .$ID), ] %>% 
  left_join(big.table %>% select(ID, Term), by = "ID") %>% 
  distinct() %>% mutate(sig = " ", sig = replace(sig, Pvalue<0.05, "*"))

kegg.plot <- kegg.plot.data %>% ggplot(aes(x = species, y = type, fill = -log10(Pvalue+0.000000001))) + 
  geom_tile(colour="black") +
  geom_text(aes(label=sig)) +
  facet_wrap(~Term, labeller = labeller(Term = label_wrap_gen(30))) + 
  scale_fill_gradient2(name = "-log10(p)", low = "steelblue", mid = "white", high = "tomato", midpoint = -log10(0.05)) + 
  theme_bw() + scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0)) + 
  theme(panel.grid = element_blank(), 
        strip.background = element_rect(fill = "white"), 
        axis.text.x = element_text(face = "italic"),
        legend.position = c(12/14, 1/12), legend.direction = "horizontal") + 
  xlab(NULL) + ylab(NULL)
ggsave(kegg.plot, file = "figures/KEGG summary fig.pdf", height = 8, width = 12)
kegg.plot
```

### Summary figure of GO results
**Figure 3**: A summary of the GO enrichment tests: GO terms with multiple red squares were significantly enriched in multiple tests. For brevity, the figure only shows GO terms for which two or more enrichment tests returned a significant result. The figure can be interpreted as for Figure S7.
```{r fig.width = 11, fig.height = 12}
go.plot.data <- plot.data %>% filter(grepl("GO", ID))
go.plot.data <- go.plot.data[go.plot.data$ID %in% (go.plot.data %>% 
                                                     group_by(ID) %>% 
                                                     summarise(n.sig = sum(Pvalue<0.05)) %>% 
                                                     filter(n.sig >1) %>% .$ID), ] %>% 
  left_join(big.table %>% select(ID, Term), by = "ID") %>% distinct() %>% 
  mutate(sig = " ", sig = replace(sig, Pvalue<0.05, "*"))
go.plot.data$Term <- with(go.plot.data, paste(toupper(substr(Term, 1, 1)), substr(Term, 2, nchar(Term)), sep=""))

go.plot <- go.plot.data %>% 
  filter(Term != "Purine nucleoside monophosphate metabolic process", # omit these 'child' GO terms for brevity
         Term != "Purine nucleoside diphosphate metabolic process",
         Term != "Purine nucleoside triphosphate metabolic process",
         Term != "Ribonucleoside monophosphate metabolic process",
         Term != "Ribonucleoside diphosphate metabolic process",
         Term != "Ribonucleoside triphosphate metabolic process") %>%
  ggplot(aes(x = species, y = type, fill = -log10(Pvalue + 0.000000001))) + 
  geom_tile(colour="black") +
  geom_text(aes(label=sig)) +
  facet_wrap(~Term, labeller = labeller(Term = label_wrap_gen(25))) + 
  scale_fill_gradient2(name = "-log10(p)", low = "steelblue", mid = "white", high = "tomato", midpoint = -log10(0.05)) + 
  theme_bw() + scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0)) + 
  theme(panel.grid = element_blank(), 
        strip.background = element_rect(fill = "white"), 
        axis.text.x = element_text(face = "italic"),
        legend.position = c(12/14, 1/12), legend.direction = "horizontal") + 
  xlab(NULL) + ylab(NULL)
ggsave(go.plot, file = "figures/GO summary fig.pdf", height = 10, width = 13)
go.plot
```




## KEGG and GO enrichment for transcriptional modules
```{r echo=FALSE}
# For the module GO tests, the gene universe is genes that are present in the network
gene.universe.modules <- OGGs[[2]]$am 
```


### Enriched KEGG and GO terms in module 1
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis for the genes in Module 1. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r}
GO.and.KEGG.enrichment(genes.in.module(1), gene.universe.modules, ontology = "BP")
```

### Enriched KEGG and GO terms in module 2
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis for the genes in Module 2. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r}
GO.and.KEGG.enrichment(genes.in.module(2), gene.universe.modules, ontology = "BP")
```

### Enriched KEGG and GO terms in module 3
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis for the genes in Module 3. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r}
GO.and.KEGG.enrichment(genes.in.module(3), gene.universe.modules, ontology = "BP") 
```

### Enriched KEGG and GO terms in module 4
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis for the genes in Module 4. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r}
GO.and.KEGG.enrichment(genes.in.module(4), gene.universe.modules, ontology = "BP") 
```

### Enriched KEGG and GO terms in module 5
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis for the genes in Module 5. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r}
GO.and.KEGG.enrichment(genes.in.module(5), gene.universe.modules, ontology = "BP")
```

### Enriched KEGG and GO terms in module 6
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis for the genes in Module 6. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r}
GO.and.KEGG.enrichment(genes.in.module(6), gene.universe.modules, ontology = "BP")
```

### Enriched KEGG and GO terms in module 7
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis for the genes in Module 7. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r}
GO.and.KEGG.enrichment(genes.in.module(7), gene.universe.modules, ontology = "BP")
```

### Enriched KEGG and GO terms in module 8
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis for the genes in Module 8. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r}
GO.and.KEGG.enrichment(genes.in.module(8), gene.universe.modules, ontology = "BP")
```

### Enriched KEGG and GO terms in module 9
**Table S`r numbering("supp.table.counter")`**: Results of KEGG and GO enrichment analysis for the genes in Module 9. The gene universe was defined as all genes for which we found an ortholog in all four species.
```{r}
GO.and.KEGG.enrichment(genes.in.module(9), gene.universe.modules, ontology = "BP")
```

## Inspect the gene list for the pheromone-sensitive module 4
**Table S`r numbering("supp.table.counter")`**: List of all the genes in Module 4, ranked by their within-module connectivity, *k*. The latter four columns give the Log$_2$ fold-change in expression in response to queen pheromone in each of the four species.
```{r warning=FALSE, message=FALSE}
inspect.module.genes(4) %>% 
  mutate(am_fc=log2(am_fc), bt_fc=log2(bt_fc), lf_fc=log2(lf_fc), ln_fc=log2(ln_fc)) %>% 
  rename(Gene=gene, Name=name) %>% 
  kable.table()
```

## Inspect the gene list for the pheromone-sensitive module 9
**Table S`r numbering("supp.table.counter")`**: List of all the genes in Module 9, ranked by their within-module connectivity, *k*. The latter four columns give the Log$_2$ fold-change in expression in response to queen pheromone in each of the four species.
```{r warning=FALSE, message=FALSE}
inspect.module.genes(9) %>% 
  mutate(am_fc=log2(am_fc), bt_fc=log2(bt_fc), lf_fc=log2(lf_fc), ln_fc=log2(ln_fc)) %>% 
  rename(Gene=gene, Name=name) %>% 
  kable.table()
```


## R session information
This section shows the operating system and R packages used to produce this document. 
```{r}
sessionInfo() %>% pander()
```

```{r echo = FALSE}
# Get rid of this file of connectivity values
unlink("blockwiseTOM-block.1.RData")
```

