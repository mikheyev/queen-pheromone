---
title: "Online Supplementary Material"
author: "From the manuscript: Queen pheromones have conserved effects on gene expression in social insects separated by 150MY of evolution"
output:
  html_document:
    toc: true # table of content true
    toc_float: true
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: yeti 
    code_folding: hide
  pdf_document: default
---

This document was prepared in R Markdown, then translated into html using the R package `knitr`. Press the buttons labelled **code** to show or hide the R code used to produce each table, plot or statistical result. For convenience, large tables can be minimised with the buttons labelled **Hide output**. 


### Load R libraries (install first from CRAN or Bioconductor)
```{r message=FALSE, warning=FALSE, results="hide"}
library(GOstats) # GO term hypergeometric tests
library(WGCNA) # Gene networks - needs 'impute' dependency: source("https://bioconductor.org/biocLite.R"); biocLite("impute")
library(RSQLite) # Access SQLite databases
library(reshape2) # data tidying (melt)
library(dplyr) # data tidying
library(tidyr) # data tidying
library(stringr) # string manipulation
library(ggplot2) # for plots
library(ggrepel) # for plots
library(ggdendro) # for plots
library(gridExtra) # for plots
library(RColorBrewer) # for plots
library(gplots) # Venn diagram
library(ecodist) # for nmds
library(MuMIn) # for model comparison
library(sva) # for ComBat function; install via source("https://bioconductor.org/biocLite.R"); biocLite("sva")
library(pander) # for nice tables
# library(GOstats) is also needed, but loaded later

# Open database connections (Sasha uses SQL, Luke prefers dplyr)
db <- dbConnect(SQLite(), dbname="data/queen pheromone.db")
my_db <- src_sqlite("data/queen pheromone.db")

# These 4 samples should not be used (See below). They were also removed in all non-R analyses (e.g. differential gene expression analyses using ebseq)
bad.samples <- c("lf1", "ln1", "ln12", "lf12")
```

```{r echo=FALSE, results='hide'}
library(knitr) # set up cacheing to save time when re-building html document
```
`r opts_chunk$set(cache=TRUE)`

### First let's check for and remove strongly outlying samples

```{r make.OGGs}
  # Define a function to get gene expression data for a given set of orthologous genes. We define orthologous genes as those that are each other's reciprocal best BLAST. The bad.samples argument can be used to remove some named samples. By default this function logs the expression data (using log10). It returns a list with two elements: the first element is a matrix of expression data (rows = samples, cols = genes), and the second is a data frame giving the species-specific names of the orthologous genes
make.OGGs <- function(species, bad.samples = NULL, log.data = T){
  
  # set up forward mappings, e.g. "am2bt", "am2lf", "am2ln"
  forward.mappings <- paste(species[1], "2", species[2:length(species)], sep = "")
  # and reverse mappings, e.g. "bt2am", "lf2am", "ln2am"
  backward.mappings <- paste(species[2:length(species)], "2", species[1], sep = "")
  items <- list() # declare empty list

  for(i in 1:length(forward.mappings)){
    
    # make a table with 3 columns: first column has species 1 gene,
    # second column has species 2 gene in forward mapping,
    # third column has species 2 gene in reverse mapping (this can be NA, or different to col 2)
    # we want the rows where cols 2 and 3 are the same, indicating reciprocity in the BLAST
    focal <- left_join(
      tbl(my_db, forward.mappings[i]) %>% select(-evalue), # get the two mappings and 
      tbl(my_db, backward.mappings[i]) %>% select(-evalue), # merge by species 1 column
      by = species[1]
    ) %>% 
      collect(n=Inf) %>% as.data.frame  # collect it all and convert to df
    
    # Get the RBB rows, and keep the two relevant columns
    focal <- focal[!is.na(focal[,3]), ]
    items[[i]] <- focal[focal[,2] == focal[,3], 1:2] 
  }
  rbbs <- items[[1]] # If 3 or 4 species, successively merge the results
  if(length(items) > 1) rbbs <- left_join(rbbs, items[[2]], by = species[1])
  if(length(items) > 2) rbbs <- left_join(rbbs, items[[3]], by = species[1])
  
  # Throw out species1 genes that do not have a RBB in all species
  rbbs <- rbbs[complete.cases(rbbs), ]
  names(rbbs) <- gsub("[.]x", "", names(rbbs)) # tidy the row and column names
  rownames(rbbs) <- NULL

  # Make sure the columns are ordered as in 'species'
  rbbs <- rbbs[, match(names(rbbs), species)]

  # We know have a list of the names of all the ortholgous genes in each species
  # Now we use these names to look up the gene expression data for each ortholog
  expression.tables <- paste("rsem_", species, sep = "")
  
  for(i in 1:length(species)){
    focal.expression <- tbl(my_db, expression.tables[i]) %>% collect(n=Inf) %>% as.data.frame()
    names(focal.expression)[names(focal.expression) == "gene"] <- species[i]
    rbbs <- left_join(rbbs, focal.expression, by = species[i])
  }
  gene.name.mappings <- rbbs[, names(rbbs) %in% species] # save gene name mappings in separate DF
  
  rownames(rbbs) <- rbbs[,1] # Use the gene names for species 1 as row names
  rbbs <- rbbs[, !(names(rbbs) %in% species)] # remove gene name columns 
  rbbs <- t(as.matrix(rbbs))

  if(log.data) rbbs <- log10(1 + rbbs)
  if(!is.null(bad.samples)) rbbs <- rbbs[!(rownames(rbbs) %in% bad.samples), ]
  
  # Discard genes where NAs appear
  gene.name.mappings <- gene.name.mappings[!(is.na(colSums(rbbs))), ]
  rbbs <- rbbs[, !(is.na(colSums(rbbs)))]

  # discard genes where expression is zero for all samples in 1 or more species
  spp <- str_replace_all(rownames(rbbs), "[:digit:]", "")
  to.keep <- rep(TRUE, ncol(rbbs))
  for(i in 1:ncol(rbbs)){
   if(min(as.numeric(tapply(rbbs[,i], spp, sum))) == 0) to.keep[i] <- FALSE
 }
rbbs <- rbbs[, to.keep]
gene.name.mappings <- gene.name.mappings[to.keep, ]

  list(tpm = rbbs, gene.mappings = gene.name.mappings)
}
```


#### 4 of the _Lasius_ samples are highly different to all of the rest
Closer inspection reveals that they are have zeros for many of the transcripts, so perhaps they had fragemented/low abundance libraries.
```{r outliers}
set.seed(1) # nmds involves random numbers, so make this plot reproducible
expression.data <- make.OGGs(c("am", "bt", "ln", "lf"))[[1]]
treatments <- tbl(my_db, "treatments") %>% as.data.frame()

shhh <- capture.output(nmds.output <- dist(expression.data) %>% nmds())
data.frame(id = rownames(expression.data), nmds.output$conf[[length(nmds.output$conf)]], stringsAsFactors = F) %>%
  left_join(treatments, by = "id") %>% 
  rename(Species = species, Treatment = treatment) %>%
  ggplot(aes(X1,X2, shape = Species)) + geom_point(aes(colour = Treatment)) + geom_text_repel(aes(label = id), size=3.6) + xlab("NMDS 1") + ylab("NMDS 2")
```
 <br/><br/> 
*Figure S1*: After reducing the transcriptome data to two axes using non-metric multidimensional scaling, four _Lasius_ samples are clear outliers.


```{r no.outliers}
set.seed(1) # nmds involves random numbers, so make this plot reproducible
expression.data <- make.OGGs(c("am", "bt", "ln", "lf"), bad.samples = bad.samples)[[1]]

shhh <- capture.output(nmds.output <- dist(expression.data) %>% nmds())
data.frame(id = rownames(expression.data), nmds.output$conf[[length(nmds.output$conf)]], stringsAsFactors = F) %>%
  left_join(treatments, by = "id") %>%
  rename(Species = species, Treatment = treatment) %>% 
  ggplot(aes(X1,X2)) + geom_point(aes(shape = Species, colour = Treatment)) + geom_text_repel(aes(label = id), size=3.6) + xlab("NMDS 1") + ylab("NMDS 2")
```
 <br/><br/> 
 *Figure S2*: With the four problematic samples removed, the samples cluster according to species with no obvious outliers.


## Testing whether gene expression is correlated across species

Specifically, these tests ask if genes that are up- (or down-) regulated in the queen pheromone treatment in one species are also up (or down) regulated in another. These tests used fold expression changes calculated using ebseq, after omitting the four irregular Lasius samples.

#### Define function to retrieve fold-change expression data (calculated with ebseq) for genes that are each other's reciprocal best BLAST
```{r fc.function}
get.fc.for.pair.species <- function(species1, species2){
  query <- 'SELECT rbb.X AS X_gene, rbb.Y AS Y_gene, ebseq_gene_X.PostFC AS X_fc, ebseq_gene_Y.PostFC AS Y_fc FROM ebseq_gene_X
             JOIN
  (SELECT Y2X.X, Y2X.Y  FROM Y2X
  JOIN X2Y
  ON Y2X.Y = X2Y.Y AND Y2X.X = X2Y.X  ) AS rbb
  ON rbb.X = ebseq_gene_X.gene
  JOIN ebseq_gene_Y
  ON rbb.Y = ebseq_gene_Y.gene'
  
  query <- str_replace_all(query, "X", species1)
  query <- str_replace_all(query, "Y", species2)
  dbGetQuery(db, query)
}
```


#### Make a table and a plot of the correlations for each pair of species
*Table S1*: Results of Spearman's rank correlations, testing whether the fold-change in gene expression in response to queen pheromone is correlated for a given pair of species. Positive coefficients (rho) indicate that on average, orthologous genes are affected in the same direction by queen pheromones.
```{r TableS1}
species.combinations <- t(combn(c("am", "bt", "lf", "ln"), 2))
rho <- numeric(nrow(species.combinations))
p <- numeric(nrow(species.combinations))
for(i in 1:nrow(species.combinations)){
  fc.data <- get.fc.for.pair.species(species.combinations[i, 1], species.combinations[i,2])
  fc.data[,3:4] <- fc.data[,3:4] %>% log2 # Log the fold changes - not that it matters for Spearman's!
  results <- suppressWarnings(with(fc.data, cor.test(fc.data[,3], fc.data[,4], method="spearman"))) # Spearman's correlation
  rho[i] <- results$estimate
  p[i] <- results$p.value
}

species.combinations <- data.frame(Species1 = species.combinations[,1],
                                   Species2  = species.combinations[,2],
                                   rho = rho,
                                   p = p,
                                   sig = " ", stringsAsFactors = F)

species.combinations[species.combinations == "am"] <- "Apis mellifera"
species.combinations[species.combinations == "bt"] <- "Bombus terrestris"
species.combinations[species.combinations == "lf"] <- "Lasius flavus"
species.combinations[species.combinations == "ln"] <- "Lasius niger"

species.combinations$sig[species.combinations$p < 0.05] <- "*"
species.combinations$sig[species.combinations$p < 0.01] <- "**"
species.combinations$sig[species.combinations$p < 0.0001] <- "***"
# Make a table
species.combinations %>% mutate(rho = format(round(rho, 3), nsmall = 3)) %>% pander
```

```{r FigureS1}
# Make a figure
species.combinations %>% ggplot(aes(Species1, Species2, fill=rho)) + geom_tile(colour="white", size=4) + scale_fill_gradient2(name = "Corr", low = brewer.pal(9, "RdYlBu")[7], mid = "white", high = brewer.pal(9, "RdYlBu")[2]) + 
  geom_text(aes(label = sig)) +
  theme_bw() + theme(panel.grid = element_blank(), panel.border = element_blank(), axis.ticks = element_blank(), axis.text = element_text(face = "italic")) + xlab(NULL) + ylab(NULL) +
  scale_x_discrete(labels = c("Apis\nmellifera", "Bombus\nterrestris", "Lasius\nflavus"), expand = c(0,0)) + 
  scale_y_discrete(labels = c("Bombus\nterrestris", "Lasius\nflavus", "Lasius\nniger"), expand = c(0,0)) 
```
 <br/><br/> 
 *Figure S3*: Results of Spearman's rank correlations, testing whether the fold-change in gene expression in response to queen pheromone is correlated for a given pair of species. The colour shows the correlation (Spearman's rho), where red  indicates that on average, orthologous genes are affected in the same direction by queen pheromones, and blue indicates the reverse. The stars show the degree of statistical significance (\*: p < 0.05, \*\* p < 0.01, \*\*\* p < 0.0001).

## Identifying genes that splice differentially following queen pheromone treatment

```{r splice.function}
# Define a function to search for significantly alternatively spliced genes. We define these as genes that have at least two differentially expressed isoforms, where queen pheromone stimulates expresison of one isoform but surpresses expression of another

find.alternatively.spliced.genes <- function(species){
  
  # Write a database query with 'X' as a placeholder for the species name
  query <- 'SELECT isoforms_X.gene, isoforms_X.isoform, PostFC FROM isoforms_X
JOIN
             (SELECT gene, COUNT(*) FROM ebseq_padj_isoform_X 
             JOIN isoforms_X
             ON isoforms_X.isoform = ebseq_padj_isoform_X.isoform
             GROUP BY gene
             HAVING COUNT(*)>1 ) AS multiISO
             ON multiIso.gene = isoforms_X.gene
             JOIN ebseq_padj_isoform_X 
             ON ebseq_padj_isoform_X.isoform = isoforms_X.isoform
             ORDER BY isoforms_X.gene'
  query <- str_replace_all(query, "X", species) # replace X with the species
  Splice <- dbGetQuery(db, query) # run the query
  
  # Find the highest and lowest fold change for the isoforms of each gene
  SpliceMin <- aggregate(Splice$PostFC, by=list(Splice$gene), FUN="min")
  SpliceMax <- aggregate(Splice$PostFC, by=list(Splice$gene), FUN="max")
  SpliceCompare <- merge(SpliceMin, SpliceMax, by = "Group.1")
  colnames(SpliceCompare) <- c("gene", "min", "max")
  
  # Define diff-spliced genes as those with both elevated and repressed isoforms, when comparing control and pheromone-treated workers
  output <- data.frame(gene = SpliceCompare$gene[SpliceCompare$min < 1 & SpliceCompare$max > 1], stringsAsFactors = F)
  
  # Add the Apis mellifera ortholog, from one-way BLAST, if it's a non-Apis species
  if(species != "am"){
    orthologs <- tbl(my_db, paste(species, "2am", sep = "")) %>% select(-evalue) %>% collect(n=Inf) %>% as.data.frame()
    names(orthologs) <- c("gene", "Amel_ortholog")
    output <- left_join(output, orthologs, by = "gene") 
    output <- left_join(output, tbl(my_db, "bee_names") %>% rename(Amel_ortholog = gene), copy=T, by = "Amel_ortholog") 
    output <- output %>% arrange(Amel_ortholog)
  }
  else output <- left_join(output, tbl(my_db, "bee_names"), by = "gene", copy = T) %>% arrange(gene)
  
  output[is.na(output)] <- " "
  
  # Remove the 'isoform X' part from the gene name, so it gives the name of the gene not the isoform
  output$name <- unlist(lapply(strsplit(output$name, split = " isoform "), function(x) x[1]))
  
  output <- left_join(output, SpliceCompare, by = "gene") 
  names(output) <- c("Gene", "Name", "Lowest FC", "Highest FC")
  output
}
```

### Genes showing pheromone-induced alternative splicing in _A. mellifera_
*Table S2*: List of genes showing statistically significant pheromone-induced alternative splicing in _A. mellifera_. These genes were defined as those that have at least two isoforms that are differentially expressed following pheromone treatment with p < 1e-05, and for which one isoform increases in expression while another decreases. The last two columns show the fold changes of the most down-regulated and most up-regulated isoforms.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r am.splice}
am.alt.splice <- find.alternatively.spliced.genes("am")
pander(am.alt.splice, split.cell = 40, split.table = Inf)
```

### Genes showing pheromone-induced alternative splicing in _L. flavus_
*Table S3*: List of genes showing statistically significant pheromone-induced alternative splicing in _L. flavus_. The table shows the same information as Table S2.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r lf.splice}
lf.alt.splice<- find.alternatively.spliced.genes("lf")
pander(lf.alt.splice, split.cell = 40, split.table = Inf)
```

### Genes showing pheromone-induced alternative splicing in _L. niger_
*Table S4*: List of genes showing statistically significant pheromone-induced alternative splicing in _L. niger_. The table shows the same information as Table S2.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r ln.splice}
ln.alt.splice <- find.alternatively.spliced.genes("ln")
pander(ln.alt.splice, split.cell = 40, split.table = Inf)
```

### There are no genes showing pheromone-sensitive splicing for _B. terrestris_
```{r bt.splice}
find.alternatively.spliced.genes("bt")  
```

### There is little overlap of pheromone-sensitive alternatively-spliced genes
```{r splice.venn}
lf.alt <- lf.alt.splice$Name[lf.alt.splice$Name != " "] # Exclude genes with no A. mellifera names
ln.alt <- ln.alt.splice$Name[ln.alt.splice$Name != " "]
venn(list(Apis = am.alt.splice$Name,`L. flavus` = lf.alt,`L. niger` = ln.alt))
```


## Gene co-expression network analysis

First, we define a series of functions for gene co-expression network analysis.
```{r network.functions}
# This function uses the ComBat function from the package 'sva' to remove variance in gene expression
# that is due to colony and species, allowing us to detect variance due to queen pheromone treatment.
# The use of ComBat in this fashion follows recommendations from the author of the WGCNA package. 
remove.effects.combat <- function(expression.data){
  sampleIDs <- rownames(expression.data)
  ids <- with(treatments[match(sampleIDs, treatments$id), ], 
              data.frame(
                id = sampleIDs,
                species = species,
                treatment = treatment,
                colony = paste(species, colony, sep = "")))
  
  modcombat <- model.matrix(~as.factor(treatment), data=ids)
  shh <- capture.output(expression.data <- ComBat(dat=t(expression.data), batch=ids$species, mod=modcombat, par.prior=T))
  shh <- capture.output(expression.data <- t(ComBat(dat=expression.data, batch=ids$colony, mod=modcombat, par.prior=T)))
  list(expression.data, ids)
}


# Build a gene coexpresison network using WGCNA package
build.network <- function(expression.data.list){
  # Pick the soft thresholding power that gives a model fit of R^2 > 0.8 for the scale-free topology model
  # Assigning the output to 'shh' prevents the function printing so much to the console
  soft.power <- pickSoftThreshold(expression.data.list[[1]], RsquaredCut = 0.8, verbose = 0, powerVector = 1:30)
  # Use this power to generate a gene co-expression network, using the default settings
  network <- blockwiseModules(expression.data.list[[1]], 
                              power = soft.power$powerEstimate,
                              networkType = "unsigned",
                              minModuleSize = 30,
                              verbose = 0,
                              saveTOMs = T)
  list(network, expression.data.list[[2]])
}


# By default, WGCNA gives the transcriptional modules random names like 'turqoise' or 'darkred'. I think it's more useful to define the biggest module as 'Module 1', the second biggest as 'Module 2', etc
# I use the label 'Module 0' for genes that were not assigned to a module
convert.module.colors.to.names <- function(network){
  module.sizes <- table(network[[1]]$colors) %>% sort %>% rev
  module.sizes <- c(module.sizes[names(module.sizes) == "grey"], module.sizes[names(module.sizes) != "grey"])
  module.mappings <- data.frame(color = names(module.sizes), 
                                new.name = paste("Module", 0:(length(module.sizes)-1)), stringsAsFactors = F)
  network[[1]]$colors <- module.mappings$new.name[match(network[[1]]$colors, module.mappings$color)]
  names(network[[1]]$MEs) <- gsub("ME", "", names(network[[1]]$MEs))
  names(network[[1]]$MEs) <- module.mappings$new.name[match(names(network[[1]]$MEs), module.mappings$color)]
  network
}


# Rearrange the data in a handy format for stats and plotting, and remove the 'Module 0', the un-assigned genes
rearrange.eigengene.data <- function(network.list){
  cbind(network.list[[2]], network.list[[1]]$MEs) %>% 
    gather(Module, Eigengene, starts_with("Module")) %>% filter(Module != "Module 0") %>%
    rename(Species = species, Treatment = treatment) %>% arrange(Species, Treatment, colony, Module)
} 


# Run a model selection analysis on each module. The full linear model has eigengene as the response variable, and treatment, species and treatment:species as predictors. We rank the 5 possible models using their AIC scores, and test which provides the best fit to the data (the 'delta' and 'weight' parameters reveal the difference in explantory power)
run.stats <- function(dat){
  
  do.one.module <- function(module, dat){
    options(na.action = "na.fail") # need to set this option when running dredge()
    full.model <- lm(Eigengene ~ Treatment * Species, data = dat[dat$Module == paste("Module", module), ])
    output <- suppressMessages(dredge(full.model)) # compare full model and the four possible simpler models
    options(na.action = "na.omit") # set it back to default
    cbind(Module = module, output %>% as.data.frame()) # Add the module name to the results
  }
  
  stats <- do.call("rbind", # Run model selection on every module
                   lapply(1:length(unique(eigen.data$Module)), do.one.module, eigen.data))

  stats[,names(stats) %in% c("logLik", "AICc", "delta", "weight")] <- format(round(stats[,names(stats) %in% c("logLik", "AICc", "delta", "weight")], 2), nsmall = 2) # rounding
  rownames(stats) <- NULL
  stats <- stats[,-2] # Remove the intercept column
  stats$Module[duplicated(stats$Module)] <- " "
  model <- rep("Null model")
  model[stats$Species == "+"] <- "~ Species"
  model[stats$Treatment == "+"] <- "~ Treatment"
  model[stats$Species == "+" & stats$Treatment == "+"] <- "~ Species + Treatment"
    model[stats$`Species:Treatment` == "+"] <- "~ Species x Treatment"
  model[is.na(model)] <- "Null model"
  stats <- with(stats, data.frame(Module, Model = model, stats[,names(stats) %in% c("logLik", "AICc", "delta", "weight")]))
  stats
}
```

### Make the gene co-expression network, using the set of orthologous genes for all 4 species
```{r make.network, results="hide", warning=FALSE}
# The 4 bad samples get removed, then we find the orthologous genes, the data are scaled with ComBat, and then we build the network using the lowest soft-thresholding power that gives at least R^2 > 0.8 model fit
OGGs <- make.OGGs(c("am", "bt", "ln", "lf"), bad.samples = bad.samples)
network <- OGGs[[1]] %>%
  remove.effects.combat() %>% 
  build.network() %>%
  convert.module.colors.to.names()
eigen.data <- network %>% rearrange.eigengene.data
```

### Simple statistics about the network
Here is the number of orthologous genes that form the network:
```{r}
length(network[[1]]$colors)
```

Here is the number and size of modules in the network - module 0 is the unassigned genes
```{r}
table(network[[1]]$colors) 
```


### Make a plot of the module eigengenes
```{r}
# Make a plot of the module eigengenes, split by species, module and treatment
treatments.network.plot <- function(dat){ 
  dat %>% ggplot(aes(Species, Eigengene, fill = Treatment)) + 
    geom_hline(yintercept = 0, colour="grey", linetype=2) + 
    geom_boxplot() + 
    facet_wrap(~Module) + 
    xlab(NULL) + 
    scale_x_discrete(labels = c("Apis\nmellifera", "Bombus\nterrestris", "Lasius\nflavus", "Lasius\nniger")) + theme_bw() + 
    theme(legend.position=c(0.9,0.1), panel.grid = element_blank(), strip.background = element_blank(), axis.text.x = element_text(face = "italic"))
}

eigen.data %>% treatments.network.plot
```
 <br/><br/> 
 *Figure S4*: The Figure shows the distribution of module eigengenes for each combination of module, species, and queen pheromone (QP) treatment. Positive values mean that the focal group has higher eigengenes, which derived from the relative expression levels of a module of genes, than the average. Queen pheromone treatment had a statistically significant effect on eigengenes for module 4. 



### Run model selection analysis to test for treatment and species effects on eigengenes

*Table S5*: Model selection analysis, using AICc (corrected Akaike Information Criterion) to rank all possible models of the module eigengene data shown in Figure S4. The models are listed from best to worst for each module. The delta column gives the different in AICc scores between the focal model and the top model in the set, where delta > 2 is considered to be a significant improvement in model fit. The column 'weight' gives Akaike weights, which can be interpreted as probabilities that the focal model is the top model in the set given the data.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r}
run.stats(eigen.data) %>% pander
```

### Plot the correlations between all modules and the pheromone treatment
```{r}
meta.module.plot <- function(network){
 
  MET <- network[[1]]$MEs 
  MET <- data.frame(QP = (network[[2]]$treatment %>% as.numeric())-1, MET) %>% select(-Module.0)
  names(MET) <- gsub("[.]", " ", names(MET))
  cluster <- (1 - cor(MET)) %>% as.dist() %>% hclust()
  ordering <- cluster$labels[cluster$order]
  heat.map.data <- cor(MET) %>% melt %>% 
    mutate(Var1 = factor(Var1, levels = ordering),
           Var2 = factor(Var2, levels = ordering)) %>% 
    rename(Corr = value)
  heat.map <- heat.map.data %>% ggplot(aes(Var1, Var2, fill = Corr)) + geom_tile() + 
    scale_fill_gradient2(low = brewer.pal(9, "RdBu")[8], mid = "white", high = brewer.pal(9, "RdBu")[2]) + xlab(NULL) + ylab(NULL) + theme_bw() + theme(panel.border = element_blank(), panel.grid = element_blank()) + 
    scale_x_discrete(expand = c(0,0)) + scale_y_discrete(expand = c(0,0))
 
  dendrogram <- ggdendrogram(cluster) + theme(axis.text.x = element_blank(), axis.text.y = element_blank())
  
  p1 <- grid.arrange(dendrogram, heat.map)
  invisible(p1)
}

meta.module.plot(network)
```
 <br/><br/> 
 *Figure S5*: Dendrogram and heat map showing the correlations among module eigengene values and the queen pheromone treatment (QP; coded as zero and 1 for the control and treatment respectively). Modules with red colour, or which are close on the dendrogram, show more correlated expression. The queen pheromone treatment was correlated with Module 4, but was relatively uncorrelated with the other modules.

## GO term enrichment for differentially _expressed_ genes
First, define some functions we will need. See also the R script "Script to set up for GO analyses.R", which was used to make the object gene_set_collection.RData, following instructions for making a GO annotation for a non-model organism at http://bioconductor.org/packages/2.11/bioc/vignettes/GOstats/inst/doc/GOstatsForUnsupportedOrganisms.pdf.

There are only two differentially expressed genes for _B. terrestris_, so it is only meaningful to test for enriched GO terms in the other three species.
```{r module.funs, warnings = FALSE}
GO.enrichment <- function(enriched.genes, gene.universe, ontology){
  params <- GSEAGOHyperGParams(name="Luke's Params",
                               geneSetCollection = gene_set_collection, # Custom GO annotations for all the OGGs
                               geneIds = enriched.genes,
                               universeGeneIds = gene.universe,
                               ontology = ontology, # Can be BP, MF, or CC
                               pvalueCutoff = 0.05,
                               conditional = TRUE, # Do the test conditional on the GO structure
                               testDirection = "over") # Look for over-represented GO terms, not under
  Over <- hyperGTest(params)
  
  summary(Over) %>% mutate(Pvalue = format(round(Pvalue, 5), nsmall = 3),
                           OddsRatio = format(round(OddsRatio, 3), nsmall = 3),
                           ExpCount = format(round(ExpCount, 3), nsmall = 3))
}

# Find the names for the genes in a given module
genes.in.module <- function(module.number){
  colnames(OGGs[[1]])[which(network[[1]]$colors == paste("Module", module.number))]
}

# Get the gene names, and sensitivity to pheromone, for genes in a certain module
inspect.module.genes <- function(module){
  gene.names <- tbl(my_db, "bee_names") %>% as.data.frame()
  gene.names <- gene.names[gene.names$gene %in% genes.in.module(module), ]
  gene.names$k <- colSums(as.matrix(TOM)[network[[1]]$colors == paste("Module", module), 
                                        network[[1]]$colors == paste("Module", module)])
  gene.names <- gene.names %>% arrange(-k)
  
  am <- tbl(my_db, "ebseq_gene_am") %>% as.data.frame()
  gene.names$am_fc <- am$PostFC[match(gene.names$gene, am$gene)]
  bt <- tbl(my_db, "ebseq_gene_bt") %>% rename(bt = gene) %>% left_join(tbl(my_db, "bt2am")) %>% as.data.frame()
  gene.names$bt_fc <- bt$PostFC[match(gene.names$gene, bt$am)]
  lf <- tbl(my_db, "ebseq_gene_lf") %>% rename(lf = gene) %>% left_join(tbl(my_db, "lf2am")) %>% as.data.frame()
  gene.names$lf_fc <- lf$PostFC[match(gene.names$gene, lf$am)]
  ln <- tbl(my_db, "ebseq_gene_ln") %>% rename(ln = gene) %>% left_join(tbl(my_db, "ln2am")) %>% as.data.frame()
  gene.names$ln_fc <- ln$PostFC[match(gene.names$gene, ln$am)]
  row.names(gene.names) <- NULL
  gene.names
}

# Load the gene set collection object needed for the GO tests
load("data/gene_set_collection.RData")

# Load the TOM object needed for connectivity of each gene
load("blockwiseTOM-block.1.RData")
```


### Enriched GO terms for differentially expressed genes in _A. mellifera_
*Table S6*: Results of GO term enrichment analysis on the list of genes showing significant differential expression in response to queen pheromone in _A. mellifera_. The gene universe was defined as all _A. mellifera_ genes measured in this study.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r apis.exp.go}
gene.universe.apis <- (tbl(my_db, "rsem_am") %>% 
                         as.data.frame())$gene
diff.expressed.apis <- (tbl(my_db, "ebseq_padj_gene_am") %>% dplyr::select(gene) %>% as.data.frame())[,1]
GO.enrichment(diff.expressed.apis, gene.universe.apis, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```


### Enriched GO terms for differentially expressed genes in _L. flavus_
*Table S7*: Results of GO term enrichment analysis on the list of genes showing significant differential expression in response to queen pheromone in _L. flavus_. The gene universe used was defined as all _L. flavus_ genes for which we detected an _A. mellifera_ ortholog.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r flavus.exp.go}
# The gene universe is all L. flavus genes for which we found a BLAST hit in Apis mellifera
gene.universe.flavus <- (left_join(tbl(my_db, "rsem_lf") %>% 
                                     dplyr::select(gene), 
                                   tbl(my_db, "lf2am") %>% 
                                     dplyr::rename(gene = lf), by = "gene") %>% 
                           dplyr::select(am) %>% 
                           filter(!is.na(am)) %>% 
                           as.data.frame())[,1] %>% unique
# The test set is all differentially expressed genes in L. flavus for which we found a BLAST hit in Apis
diff.expressed.flavus <- (left_join(tbl(my_db, "ebseq_padj_gene_lf") %>% dplyr::select(gene), 
                                   tbl(my_db, "lf2am") %>% dplyr::rename(gene = lf), by = "gene") %>% 
                           dplyr::select(am) %>% filter(!is.na(am)) %>% as.data.frame())[,1] %>% unique
GO.enrichment(diff.expressed.flavus, gene.universe.flavus, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```

### Enriched GO terms for differentially expressed genes in _L. niger_
*Table S8*: Results of GO term enrichment analysis on the list of genes showing significant differential expression in response to queen pheromone in _L. niger_. The gene universe used was defined as all _L. niger_ genes for which we detected an _A. mellifera_ ortholog.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r niger.exp.go}
# The gene universe is all L. niger genes for which we found a BLAST hit in Apis mellifera
gene.universe.niger <- (left_join(tbl(my_db, "rsem_ln") %>% 
                                    dplyr::select(gene), 
                                   tbl(my_db, "ln2am") %>% 
                                    dplyr::rename(gene = ln), by = "gene") %>% 
                           dplyr::select(am) %>% 
                          filter(!is.na(am)) %>% 
                          as.data.frame())[,1] %>% unique
# The test set is all differentially expressed genes in L. niger for which we found a BLAST hit in Apis
diff.expressed.niger <- (left_join(tbl(my_db, "ebseq_padj_gene_ln") %>% dplyr::select(gene), 
                                   tbl(my_db, "ln2am") %>% dplyr::rename(gene = ln), by = "gene") %>% 
                           dplyr::select(am) %>% filter(!is.na(am)) %>% as.data.frame())[,1] %>% unique
GO.enrichment(diff.expressed.niger, gene.universe.niger, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```

## Find the number of intersecting differentially-expressed orthologous genes across species
Bombus is omitted because there were only 2 differentially expressed genes and both are absent in the other three species.
```{r find.intersect}
overlap.counts <- table(c(diff.expressed.apis, diff.expressed.flavus, diff.expressed.niger))
overlap.thrice <- names(overlap.counts[overlap.counts == 3])

overlap.thrice <- tbl(my_db, "bee_names") %>% dplyr::filter(gene == overlap.thrice) %>% 
  mutate(Species = "Apis and both Lasius") %>%  as.data.frame()

overlap.counts <- table(c(diff.expressed.flavus, diff.expressed.apis))
overlap.apis.flavus <- names(overlap.counts[overlap.counts==2])
overlap.apis.flavus <- tbl(my_db, "bee_names") %>% dplyr::filter(gene %in% overlap.apis.flavus) %>% 
  mutate(Species = "Apis and L. flavus")%>% as.data.frame()

overlap.counts <- table(c(diff.expressed.niger, diff.expressed.apis))
overlap.apis.niger <- names(overlap.counts[overlap.counts==2])
overlap.apis.niger <- tbl(my_db, "bee_names") %>% dplyr::filter(gene %in% overlap.apis.niger) %>%
  mutate(Species = "Apis and L. niger") %>% as.data.frame()

overlap.counts <- table(c(diff.expressed.flavus, diff.expressed.niger))
overlap.lasius <- names(overlap.counts[overlap.counts==2])
overlap.lasius <- tbl(my_db, "bee_names") %>% dplyr::filter(gene %in% overlap.lasius) %>% 
  mutate(Species = "L. flavus and L. niger") %>% as.data.frame()

all.overlaps <- rbind(overlap.thrice, overlap.apis.flavus, overlap.apis.niger, overlap.lasius)
all.overlaps <- all.overlaps[!duplicated(all.overlaps$name), ]
names(all.overlaps)[1:2] <- c("Gene", "Name")
rownames(all.overlaps) <- NULL
```

*Table S9*: Names of all the orthologous genes that were significantly differentially expressed between pheromone treatments in more than one species.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r overlap.table}
pander(all.overlaps, split.cell = 40, split.table = Inf)
```

### Venn diagram showing number of overlapping differentially expressed genes
```{r expr.venn}
venn(list(Apis = diff.expressed.apis,`L. flavus` = diff.expressed.flavus,`L. niger` = diff.expressed.niger))
```
 <br/><br/> 
 *Figure S6*: Venn diagram showing number significantly differentially expressed genes in each species, as well as the overlap.



### GO term enrichment for genes whose expression is affected by queen pheromone in more than one species
*Table S10*: Results of GO term enrichment analysis on the list of genes showing significant differential expression in response to queen pheromone in two or more species. The gene universe used was defined as all genes for which we found an ortholog in all four species.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r overlap.go}
GO.enrichment(all.overlaps$Gene %>% unique, gene.universe.apis, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```


## GO term enrichment for differentially spliced genes

### GO terms for _A. mellifera_ genes showing pheromone-modulated alternative splicing
```{r apis.spl.go}
# The gene universe is defined as all genes that have 2 or more isoforms. It would be anti-conservative if we instead included all genes, not just that are alternatively spliced
gene.universe.apis.splicing <- (tbl(my_db, "isoforms_am") %>% 
                                  group_by(gene) %>% 
                                  summarise(nIsoforms = n()) %>% filter(nIsoforms > 1) %>% 
                                  as.data.frame() %>% 
                                  dplyr::select(gene) %>% as.data.frame())[,1]
```

*Table S11*: Results of GO term enrichment analysis on the list of genes showing significant alternative splicing in _A. mellifera_. The gene universe used was defined as all genes that showed alternative splicing in _A. mellifera_.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r apis.go}
GO.enrichment(am.alt.splice$Gene, gene.universe.apis.splicing, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```

### GO terms for _L. flavus_ genes showing pheromone-modulated alternative splicing
```{r flavus.spl.go}
# For flavus and niger, we additionally have to find the best BLAST Apis genes when constructing the gene lists
gene.universe.flavus.splicing <- (tbl(my_db, "isoforms_lf") %>% 
                                  group_by(gene) %>% 
                                  summarise(nIsoforms = n()) %>% filter(nIsoforms > 1) %>% 
                                  as.data.frame() %>% 
                                  dplyr::select(gene) %>% as.data.frame())[,1]

gene.universe.flavus.splicing <- (tbl(my_db, "lf2am") %>%  # Convert to Apis gene names via BLAST
                         filter(lf %in% gene.universe.flavus.splicing) %>% 
                         dplyr::select(am) %>% filter(!is.na(am)) %>% as.data.frame())[,1]

alt.spliced.flavus <- (tbl(my_db, "lf2am") %>% 
                         filter(lf %in% lf.alt.splice$Gene) %>% 
                         dplyr::select(am) %>% filter(!is.na(am)) %>% as.data.frame())[,1]
```

*Table S12*: Results of GO term enrichment analysis on the list of genes showing significant alternative splicing in _L. flavus_. The gene universe used was defined as all genes that showed alternative splicing in _L. flavus_, which also had a known ortholog in _A. mellifera_.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r}
GO.enrichment(alt.spliced.flavus, gene.universe.flavus, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```

### GO terms for _L. niger genes showing pheromone-modulated alternative splicing
```{r niger.spl.go}
gene.universe.niger.splicing <- (tbl(my_db, "isoforms_ln") %>% 
                                  group_by(gene) %>% 
                                  summarise(nIsoforms = n()) %>% filter(nIsoforms > 1) %>% 
                                  as.data.frame() %>% 
                                  dplyr::select(gene) %>% as.data.frame())[,1]

gene.universe.niger.splicing <- (tbl(my_db, "ln2am") %>%  # Convert to Apis gene names via BLAST
                         filter(ln %in% gene.universe.niger.splicing) %>% 
                         dplyr::select(am) %>% filter(!is.na(am)) %>% as.data.frame())[,1] %>%
  unique

alt.spliced.niger <- (tbl(my_db, "ln2am") %>% 
                        filter(ln %in% ln.alt.splice$Gene) %>% 
                        dplyr::select(am)%>% filter(!is.na(am)) %>% as.data.frame())[,1]
```

*Table S13*: Results of GO term enrichment analysis on the list of genes showing significant alternative splicing in _L. niger_. The gene universe used was defined as all genes that showed alternative splicing in _L. niger_, which also had a known ortholog in _A. mellifera_.
```{r}
GO.enrichment(alt.spliced.niger, gene.universe.niger.splicing, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```


## GO term enrichment for transcriptional modules
```{r echo=FALSE}
# For the module GO tests, the gene universe is genes that are present in the network
gene.universe.modules <- OGGs[[2]]$am 
```


### Enriched GO terms in module 1
*Table S14*: Results of GO term enrichment analysis for the genes in Module 1. The gene universe used was defined as all genes for which we found an ortholog in all four species.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r}
GO.enrichment(genes.in.module(1), gene.universe.modules, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```

### Enriched GO terms in module 2
*Table S15*: Results of GO term enrichment analysis for the genes in Module 2. The gene universe used was defined as all genes for which we found an ortholog in all four species.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r}
GO.enrichment(genes.in.module(2), gene.universe.modules, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```

### Enriched GO terms in module 3
*Table S16*: Results of GO term enrichment analysis for the genes in Module 3. The gene universe used was defined as all genes for which we found an ortholog in all four species.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r}
GO.enrichment(genes.in.module(3), gene.universe.modules, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```

### Enriched GO terms in module 4
*Table S17*: Results of GO term enrichment analysis for the genes in Module 4. The gene universe used was defined as all genes for which we found an ortholog in all four species.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r}
GO.enrichment(genes.in.module(4), gene.universe.modules, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```

### Enriched GO terms in module 5
*Table S18*: Results of GO term enrichment analysis for the genes in Module 5. The gene universe used was defined as all genes for which we found an ortholog in all four species.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r}
GO.enrichment(genes.in.module(5), gene.universe.modules, ontology = "BP") %>%
  pander(split.cell = 40, split.table = Inf)
```


### Inspect the gene list for the pheromone-sensitive module 4
*Table S19*: List of all the genes in Module 4, ranked by their within-module connectivity, *k*. The latter four columns give the Log2 fold-change in expression in response to queen pheromone in each of the four species.
 <br/><br/> 
<input type=button class=hideshow></input>
```{r echo=FALSE, warning=FALSE, message=FALSE}
inspect.module.genes(4) %>% 
  mutate(am_fc=log2(am_fc), bt_fc=log2(bt_fc), lf_fc=log2(lf_fc), ln_fc=log2(ln_fc)) %>% 
  rename(Gene=gene, Name=name) %>% 
  pander(split.cell = 40, split.table = Inf)
```

### Plot the gene list for the pheromone-sensitive module 4
```{r echo=FALSE, warning=FALSE, message=FALSE}
melt(inspect.module.genes(4)[,c(2,4:7)]) %>% 
  rename(Gene = name, Species = variable, FC = value) %>% 
  mutate(FC=log2(FC), Gene = factor(Gene, levels = rev(unique(Gene)))) %>% 
  ggplot(aes(Species, Gene, fill=FC)) + geom_tile(colour="black") + 
  scale_fill_gradient2(name = "Log2(FC)", low = brewer.pal(9, "RdYlBu")[7], mid = "white", high = brewer.pal(9, "RdYlBu")[2]) +
  scale_x_discrete(labels = c("Apis\nmellifera", "Bombus\nterrestris", "Lasius\nflavus", "Lasius\nniger"), expand=c(0,0)) +
  scale_y_discrete(expand=c(0,0)) + theme_bw() + theme(panel.grid = element_blank(), axis.text.x = element_text(face = "italic"))
```
 <br/><br/> 
 *Figure S7*: Change in expression for all the genes in Module 4, in each species (i.e. the same data as in Table S19). The genes are ranked from most (top) to least (bottom) connected, using within-module connectedness. Genes in this module were mostly upregualted in _A. mellifera_ and downregualted in the other species (the colour shows log fold-change in expression in response to queen pheromone). 



<!-- Some JavaScript to control the buttons to show/hide the big tables -->
<script>
$( "input.hideshow" ).each( function ( index, button ) {
  button.value = 'Hide Output';
  $( button ).click( function () {
    var target = this.nextSibling ? this : this.parentNode;
     target = target.nextSibling.nextSibling.nextSibling.nextSibling.nextSibling;
    if ( target.style.display == 'block' || target.style.display == '' ) {
      target.style.display = 'none';
      this.value = 'Show Output';
    } else {
      target.style.display = 'block';
      this.value = 'Hide Output';
    }
  } );
} );
</script>




<!-- ## Now plot the network to look at the modules that we identified -->
<!-- ```{r} -->
<!-- module.cluster.plot <- function(network){ -->
<!--   modules <- as.numeric(gsub("Module ", "", network$colors)) -->
<!--   moduleColors <- labels2colors(c(0, 1:max(modules))) -->
<!--     print(moduleColors) -->

<!--   sizeGrWindow(12,6) -->
<!--   # Use the layout function for more involved screen sectioning -->
<!--   layout(matrix(1:2, 2), heights = c(0.8, 0.2), widths = c(1,1)) -->
<!--   # Plot the consensus network dendrogram and the module colors underneath for each block -->
<!--   plotDendroAndColors(network$dendrograms[[1]], moduleColors[1 + modules], -->
<!--                       "Module colors", -->
<!--                       main = "Gene dendrogram and module colors", -->
<!--                       dendroLabels = FALSE, hang = 0.03, -->
<!--                       addGuide = TRUE, guideHang = 0.05, -->
<!--                       setLayout = FALSE) -->
<!-- } -->

<!-- module.cluster.plot(network[[1]]) -->
<!-- ``` -->





