---
title: "Queen pheromone gene expression analysis"
author: "Sasha Mikheyev"
date: "5/3/2017"
output:
  html_document: default
  pdf_document: default
---

```{r message=FALSE, warning=FALSE}
library(RSQLite)
library(WGCNA)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(ggrepel)
library(lme4)
library(car)
library(RColorBrewer)
library(ecodist)
allowWGCNAThreads()

db <- dbConnect(SQLite(), dbname="data/queen pheromone.db")
```


## Comparing whether gene expression is correlated across species

### Define helper function to retrieve fold-change expression data on genes that are each other's reciprocal best BLAST
```{r}
get.fc.for.pair.species <- function(species1, species2){
  query <- 'SELECT rbb.X AS X_gene, rbb.Y AS Y_gene, ebseq_gene_X.PostFC AS X_fc, ebseq_gene_Y.PostFC AS Y_fc FROM ebseq_gene_X
             JOIN
  (SELECT Y2X.X, Y2X.Y  FROM Y2X
  JOIN X2Y
  ON Y2X.Y = X2Y.Y AND Y2X.X = X2Y.X  ) AS rbb
  ON rbb.X = ebseq_gene_X.gene
  JOIN ebseq_gene_Y
  ON rbb.Y = ebseq_gene_Y.gene'
  
  query <- str_replace_all(query, "X", species1)
  query <- str_replace_all(query, "Y", species2)
  dbGetQuery(db, query)
}
```

### _L. niger vs. L. flavus_ 
```{r}
l2l <- get.fc.for.pair.species("lf", "ln")
with(l2l, cor.test(lf_fc, ln_fc, method="spearman"))
```

### _L. niger vs._ bumblebees
```{r}
l2b <- get.fc.for.pair.species("ln", "bt")
with(l2b, cor.test(ln_fc, bt_fc,method="s"))
```

### _L. niger vs._ honey bees
```{r}
l2a <- get.fc.for.pair.species("ln", "am")
cor.test(l2a$ln_fc, l2a$am_fc, method="spearman")
```

### _L. flavus vs._ bumblebees
```{r}
l2b <- get.fc.for.pair.species("lf", "bt")
with(l2b, cor.test(lf_fc, bt_fc,method="spearman"))
```

### _L. flavus vs._ honey bees
```{r}
l2a <- get.fc.for.pair.species("lf", "am")
with(l2a, cor.test(lf_fc, am_fc, method="spearman"))
```

### Bumblebees _vs._ honey bees
```{r}
b2a <- get.fc.for.pair.species("bt", "am")
with(b2a, cor.test(bt_fc, am_fc, method="spearman"))
```

## Identifying differential splicing

#### Define a function to search for significantly alternatively spliced genes. We define these as genes that have at least two differentially expressed isoforms, where queen pheromone stimulates expresison of one isoform but surpresses expression of another
```{r}
find.alternatively.spliced.genes <- function(species){
  query <- 'SELECT isoforms_X.gene, isoforms_X.isoform, PostFC FROM isoforms_X
JOIN
             (SELECT gene, COUNT(*) FROM ebseq_padj_isoform_X 
             JOIN isoforms_X
             ON isoforms_X.isoform = ebseq_padj_isoform_X.isoform
             GROUP BY gene
             HAVING COUNT(*)>1 ) AS multiISO
             ON multiIso.gene = isoforms_X.gene
             JOIN ebseq_padj_isoform_X 
             ON ebseq_padj_isoform_X.isoform = isoforms_X.isoform
             ORDER BY isoforms_X.gene'
  query <- str_replace_all(query, "X", species)
  Splice <- dbGetQuery(db, query)
  
  SpliceMin <- aggregate(Splice$PostFC, by=list(Splice$gene), FUN="min")
  SpliceMax <- aggregate(Splice$PostFC, by=list(Splice$gene), FUN="max")
  SpliceCompare <- merge(SpliceMin, SpliceMax, by = "Group.1")
  colnames(SpliceCompare) <- c("gene", "min", "max")
  output <- data.frame(gene = SpliceCompare$gene[SpliceCompare$min < 1 & SpliceCompare$max > 1], stringsAsFactors = F)
  if(species != "am"){
    rbb <- get.fc.for.pair.species(species, "am")[,1:2]
    names(rbb) <- c("gene", "Amel_ortholog_rbb")
    output <- left_join(output, rbb, by = "gene") 
  }
  
  left_join(output, SpliceCompare, by = "gene") 
}
```

### Honey bees
```{r}
am.alt.splice <- find.alternatively.spliced.genes("am")
am.alt.splice
```

### _L. flavus_
```{r}
lf.alt.splice<- find.alternatively.spliced.genes("lf")
lf.alt.splice
```

### _L. niger_
```{r}
ln.alt.splice <- find.alternatively.spliced.genes("ln")
ln.alt.splice
```

### Bumblebees
```{r}
find.alternatively.spliced.genes("bt")  # There are none for B. terrestris
```

## Inspect the GO terms associated with each of the differentially-spliced genes
```{r}
go.analysis.splicing <- function(splice.results, ontology){
  
  if("Amel_ortholog_rbb" %in% names(splice.results))  
    splice.results <- splice.results %>% filter(!is.na(Amel_ortholog_rbb)) %>% select(-gene) %>% rename(gene = Amel_ortholog_rbb)
  go.terms <- tbl(my_db, "bee_go") %>% filter(gene %in% splice.results$gene) %>% collect(n = Inf) %>% as.data.frame()
  suppressMessages(require(GO.db))
  go.meanings <- suppressMessages(AnnotationDbi::select(GO.db, unique(go.terms$GO), c("ONTOLOGY", "TERM")))
  names(go.meanings) <- c("GO", "ontology", "term")


  output <- left_join(go.terms, go.meanings, by = "GO") 
  output <- cbind(left_join(data.frame(gene = output$gene, stringsAsFactors = F), 
                            tbl(my_db, "bee_names"), copy = T, by = "gene"),
                       output[,-1])
  if(ontology == "BP") output <- output %>% filter(ontology == "BP")
  if(ontology == "CC") output <- output %>% filter(ontology == "CC")
  if(ontology == "MF") output <- output %>% filter(ontology == "MF")
  output %>% select(-ontology)
  
}

go.analysis.splicing(am.alt.splice, "BP")
go.analysis.splicing(lf.alt.splice, "BP")
go.analysis.splicing(ln.alt.splice, "BP")
```

## Gene co-expression network analysis
### Get TPM for the set of all orthologous genes for network analysis
```{r}
tpm <- dbGetQuery(db,
                  'SELECT DISTINCT bt2am.am AS id, rsem_am.*, rsem_bt.*, rsem_ln.*, rsem_lf.* FROM am2bt
JOIN bt2am
ON am2bt.bt = bt2am.bt AND bt2am.bt = bt2am.bt
JOIN (SELECT ln2am.am, ln2am.ln  FROM ln2am
    JOIN am2ln
    ON ln2am.ln = am2ln.ln AND ln2am.am = am2ln.am  ) AS rbb_amln
ON rbb_amln.am = bt2am.am
JOIN (SELECT lf2am.am, lf2am.lf  FROM lf2am
    JOIN am2lf
        ON lf2am.lf = am2lf.lf AND lf2am.am = am2lf.am  ) AS rbb_amlf
ON rbb_amlf.am = bt2am.am 
JOIN rsem_am
ON rsem_am.gene = bt2am.am
JOIN rsem_bt
ON rsem_bt.gene = bt2am.bt
JOIN rsem_ln
ON rsem_ln.gene = rbb_amln.ln
JOIN rsem_lf
ON rsem_lf.gene = rbb_amlf.lf
GROUP BY id')
tpm <- tpm[, which(!grepl("gene", colnames(tpm)))]
rownames(tpm) <- tpm$id
tpm <- t(tpm[, -1])
tpm <- log(1+tpm)     ## NOTE THAT WE HAVE LOGGED THE EXPRESSION DATA

treatments <- dbGetQuery(db, 'SELECT * FROM treatments')

```

### Check for and remove strongly outlying samples
```{r}
nmds.output <- dist(tpm) %>% nmds()
data.frame(id = rownames(tpm), nmds.output$conf[[length(nmds.output$conf)]], stringsAsFactors = F) %>% left_join(treatments, by = "id")  %>% ggplot(aes(X1,X2, shape = species)) + geom_point(aes(colour = treatment)) + geom_text_repel(aes(label = id), size=3.6) + xlab("NMDS 1") + ylab("NMDS 2")

tpm <- tpm[!(rownames(tpm) %in% c("lf2", "lf15", "ln9", "ln10")), ]
treatments <- treatments[!(treatments$id %in% c("lf2", "lf15", "ln9", "ln10")), ] # am5 is also a little weird

# Check that everything is ok with the data, as judged by WGCNA package - yes it is
goodSamplesGenes(tpm)$allOK

```

### Have a look at the clustering now that the outliers have been removed
```{r}
nmds.output <- dist(tpm) %>% nmds()
data.frame(id = rownames(tpm), nmds.output$conf[[length(nmds.output$conf)]], stringsAsFactors = F) %>% left_join(treatments, by = "id")  %>% ggplot(aes(X1,X2)) + geom_point(aes(shape = species, colour = treatment)) + geom_text_repel(aes(label = id), size=3.6) + xlab("NMDS 1") + ylab("NMDS 2")
```

### First we need to choose a 'soft thresholding power' for the construction of the network
```{r}
threshold.powers <- pickSoftThreshold(tpm, powerVector = 1:30, verbose = 0) # We choose power 1

threshold.powers[[2]] %>% ggplot(aes(x = Power, y = SFT.R.sq)) + geom_hline(yintercept = 0.9,linetype=2) + geom_point() + geom_line()
```

```{r}
soft.power <- 1
# Make the network using the all-in-one function from WGCNA
network <- blockwiseModules(tpm, power = soft.power,
                            networkType = "unsigned", 
                            minModuleSize = 30,
                            maxBlockSize = 9000,
                            deepSplit = 2, 
                            pamRespectsDendro = FALSE,
                            ht = 0.25, numericLabels = TRUE, 
                            saveTOMs = FALSE, verbose = 0)
```

### Here is the number of genes per module:
```{r}
table(network$colors)
```

### Now plot the network to look at the modules that we identified
```{r}
module.cluster.plot <- function(network){
  moduleColors <- labels2colors(c(0,1:max(network$colors)))
  sizeGrWindow(12,6)
  # Use the layout function for more involved screen sectioning
  layout(matrix(1:2, 2), heights = c(0.8, 0.2), widths = c(1,1))
  #layout.show(4);
  
  # Plot the consensus network dendrogram and the module colors underneath for each block
  plotDendroAndColors(network$dendrograms[[1]], moduleColors[1 + network$colors],
                      "Module colors",
                      main = "Gene dendrogram and module colors",
                      dendroLabels = FALSE, hang = 0.03,
                      addGuide = TRUE, guideHang = 0.05,
                      setLayout = FALSE)
}

module.cluster.plot(network)
```

### Plot the eigengene for each combination of species, treatment and module
```{r}
eigengenes <- data.frame(id = rownames(tpm), network$MEs, stringsAsFactors = F) %>%
  left_join(treatments, by = "id") %>%
  gather(key = module, value = eigengene, starts_with("ME")) %>%
  mutate(colony = paste(species, colony, sep=""),
         module = factor(module, levels = paste("ME", 0:length(unique(module)), sep="")))

eigengenes %>% ggplot(aes(x = species, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")

```

### Examine just the honeybee data
```{r}
eigengenes %>% filter(species == "am") %>% ggplot(aes(x = treatment, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")
```

### Examine just the bumblebee data
```{r}
eigengenes %>% filter(species == "bt") %>% ggplot(aes(x = treatment, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")
```

### Examine just the _L. flavus_ data
```{r}
eigengenes %>% filter(species == "lf") %>% ggplot(aes(x = treatment, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")
```

### Examine just the _L. niger_ data
```{r}
eigengenes %>% filter(species == "ln") %>% ggplot(aes(x = treatment, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")
```

### Run a linear mixed model on each module
```{r}
mods <- unique(eigengenes$module)
outputs <- list()

for(i in 1:length(mods)) outputs[[i]] <- Anova(lmer(eigengene ~ species + treatment + (1|colony), 
                                                    data = eigengenes[eigengenes$module == mods[i], ]), Type = "III")
names(outputs) <- paste("Results for module", mods)
outputs
```