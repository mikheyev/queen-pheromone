---
title: "Queen pheromone gene expression analysis"
author: "Sasha Mikheyev"
date: "5/3/2017"
output:
  html_document: default
  pdf_document: default
---

```{r message=FALSE, warning=FALSE}
library(RSQLite)
library(WGCNA)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggrepel)
library(lme4)
library(car)
library(RColorBrewer)
library(ecodist)
allowWGCNAThreads()

db <- dbConnect(SQLite(), dbname="data/queen pheromone.db")
```


## Comparing whether gene expression is correlated across species
### _L. niger vs. L. flavus_ 
```{r}
get.fc.for.pair.species <- function(species1, species2){
  require(stringr)
  query <- 'SELECT rbb.X AS X_gene, rbb.Y AS Y_gene, ebseq_gene_X.PostFC AS X_fc, ebseq_gene_Y.PostFC AS Y_fc FROM ebseq_gene_X
             JOIN
  (SELECT Y2X.X, Y2X.Y  FROM Y2X
  JOIN X2Y
  ON Y2X.Y = X2Y.Y AND Y2X.X = X2Y.X  ) AS rbb
  ON rbb.X = ebseq_gene_X.gene
  JOIN ebseq_gene_Y
  ON rbb.Y = ebseq_gene_Y.gene'
  
  query <- str_replace_all(query, "X", species1)
  query <- str_replace_all(query, "Y", species2)
  
  dbGetQuery(db, query)
}


l2l <- get.fc.for.pair.species("lf", "ln")
with(l2l, cor.test(lf_fc, ln_fc, method="spearman"))
```

### _L. niger vs._ bumblebees
```{r}
l2b <- get.fc.for.pair.species("ln", "bt")

with(l2b, cor.test(ln_fc, bt_fc,method="s"))
```

### _L. niger vs._ honey bees
```{r}
l2a <- get.fc.for.pair.species("ln", "am")

cor.test(l2a$ln_fc, l2a$am_fc, method="spearman")
```

### _L. flavus vs._ bumblebees
```{r}
l2b <- get.fc.for.pair.species("lf", "bt")
with(l2b, cor.test(lf_fc, bt_fc,method="spearman"))
```

### _L. flavus vs._ honey bees
```{r}
l2a <- get.fc.for.pair.species("lf", "am")

with(l2a, cor.test(lf_fc, am_fc, method="spearman"))
```

### Bumblebees _vs._ honey bees
```{r}
b2a <- get.fc.for.pair.species("bt", "am")

with(b2a, cor.test(bt_fc, am_fc, method="spearman"))
```

## Identifying differential splicing

### Honey bees
```{r}
amSplice<- dbGetQuery(db, 'SELECT isoforms_am.gene, isoforms_am.isoform, PostFC FROM isoforms_am
JOIN
    (SELECT gene, COUNT(*) FROM ebseq_padj_isoform_am 
    JOIN isoforms_am
    ON isoforms_am.isoform = ebseq_padj_isoform_am.isoform
    GROUP BY gene
    HAVING COUNT(*)>1 ) AS multiISO
ON multiIso.gene = isoforms_am.gene
JOIN ebseq_padj_isoform_am 
ON ebseq_padj_isoform_am.isoform = isoforms_am.isoform
ORDER BY isoforms_am.gene')
amSpliceMin <- aggregate(amSplice$PostFC, by=list(amSplice$gene), FUN="min")
amSpliceMax <- aggregate(amSplice$PostFC, by=list(amSplice$gene), FUN="max")
amSpliceCompare <- merge(amSpliceMin, amSpliceMax, by = "Group.1")
colnames(amSpliceCompare) <- c("gene", "min", "max")
amSpliceCompare$gene[amSpliceCompare$min < 1 & amSpliceCompare$max > 1]
```

### _L. flavus_
```{r}
lfSplice<- dbGetQuery(db, 'SELECT isoforms_lf.gene, isoforms_lf.isoform, PostFC FROM isoforms_lf
JOIN
    (SELECT gene, COUNT(*) FROM ebseq_padj_isoform_lf 
    JOIN isoforms_lf
    ON isoforms_lf.isoform = ebseq_padj_isoform_lf.isoform
    GROUP BY gene
    HAVING COUNT(*)>1 ) AS multiISO
ON multiIso.gene = isoforms_lf.gene
JOIN ebseq_padj_isoform_lf 
ON ebseq_padj_isoform_lf.isoform = isoforms_lf.isoform
ORDER BY isoforms_lf.gene')
lfSpliceMin <- aggregate(lfSplice$PostFC, by=list(lfSplice$gene), FUN="min")
lfSpliceMax <- aggregate(lfSplice$PostFC, by=list(lfSplice$gene), FUN="max")
lfSpliceCompare <- merge(lfSpliceMin, lfSpliceMax, by = "Group.1")
colnames(lfSpliceCompare) <- c("gene", "min", "max")
lfSpliceCompare$gene[lfSpliceCompare$min < 1 & lfSpliceCompare$max > 1]

lf2am <- dbGetQuery(db, 'SELECT lf2am.am, lf2am.lf, name FROM lf2am
JOIN bee_names
ON bee_names.gene = lf2am.am')

merge(lfSpliceCompare[lfSpliceCompare$min < 1 & lfSpliceCompare$max > 1,], lf2am, by.x="gene", by.y="lf")
```

### _L. niger_
```{r}
lnSplice<- dbGetQuery(db, 'SELECT isoforms_ln.gene, isoforms_ln.isoform, PostFC FROM isoforms_ln
JOIN
    (SELECT gene, COUNT(*) FROM ebseq_padj_isoform_ln 
    JOIN isoforms_ln
    ON isoforms_ln.isoform = ebseq_padj_isoform_ln.isoform
    GROUP BY gene
    HAVING COUNT(*)>1 ) AS multiISO
ON multiIso.gene = isoforms_ln.gene
JOIN ebseq_padj_isoform_ln 
ON ebseq_padj_isoform_ln.isoform = isoforms_ln.isoform
ORDER BY isoforms_ln.gene')
lnSpliceMin <- aggregate(lnSplice$PostFC, by=list(lnSplice$gene), FUN="min")
lnSpliceMax <- aggregate(lnSplice$PostFC, by=list(lnSplice$gene), FUN="max")
lnSpliceCompare <- merge(lnSpliceMin, lnSpliceMax, by = "Group.1")
colnames(lnSpliceCompare) <- c("gene", "min", "max")
lnSpliceCompare$gene[lnSpliceCompare$min < 1 & lnSpliceCompare$max > 1]

ln2am <- dbGetQuery(db, 'SELECT ln2am.am, ln2am.ln, name FROM ln2am
JOIN bee_names
ON bee_names.gene = ln2am.am')

merge(lnSpliceCompare[lnSpliceCompare$min < 1 & lnSpliceCompare$max > 1,], ln2am, by.x="gene", by.y="ln")
```

### Bumblebees
```{r}
btSplice<- dbGetQuery(db, 'SELECT isoforms_bt.gene, isoforms_bt.isoform, PostFC FROM isoforms_bt
JOIN
    (SELECT gene, COUNT(*) FROM ebseq_padj_isoform_bt 
    JOIN isoforms_bt
    ON isoforms_bt.isoform = ebseq_padj_isoform_bt.isoform
    GROUP BY gene
    HAVING COUNT(*)>1 ) AS multiISO
ON multiIso.gene = isoforms_bt.gene
JOIN ebseq_padj_isoform_bt 
ON ebseq_padj_isoform_bt.isoform = isoforms_bt.isoform
ORDER BY isoforms_bt.gene')
btSpliceMin <- aggregate(btSplice$PostFC, by=list(btSplice$gene), FUN="min")
btSpliceMax <- aggregate(btSplice$PostFC, by=list(btSplice$gene), FUN="max")
btSpliceCompare <- merge(btSpliceMin, btSpliceMax, by = "Group.1")
colnames(btSpliceCompare) <- c("gene", "min", "max")
btSpliceCompare$gene[btSpliceCompare$min < 1 & btSpliceCompare$max > 1]

bt2am <- dbGetQuery(db, 'SELECT bt2am.am, bt2am.bt, name FROM bt2am
JOIN bee_names
ON bee_names.gene = bt2am.am')

merge(btSpliceCompare[btSpliceCompare$min < 1 & btSpliceCompare$max > 1,], bt2am, by.x="gene", by.y="bt")
```
## Gene co-expression network analysis
### Get TPM for the set of all orthologous genes for network analysis
```{r}
tpm <- dbGetQuery(db,
                  'SELECT DISTINCT bt2am.am AS id, rsem_am.*, rsem_bt.*, rsem_ln.*, rsem_lf.* FROM am2bt
JOIN bt2am
ON am2bt.bt = bt2am.bt AND bt2am.bt = bt2am.bt
JOIN (SELECT ln2am.am, ln2am.ln  FROM ln2am
    JOIN am2ln
    ON ln2am.ln = am2ln.ln AND ln2am.am = am2ln.am  ) AS rbb_amln
ON rbb_amln.am = bt2am.am
JOIN (SELECT lf2am.am, lf2am.lf  FROM lf2am
    JOIN am2lf
        ON lf2am.lf = am2lf.lf AND lf2am.am = am2lf.am  ) AS rbb_amlf
ON rbb_amlf.am = bt2am.am 
JOIN rsem_am
ON rsem_am.gene = bt2am.am
JOIN rsem_bt
ON rsem_bt.gene = bt2am.bt
JOIN rsem_ln
ON rsem_ln.gene = rbb_amln.ln
JOIN rsem_lf
ON rsem_lf.gene = rbb_amlf.lf
GROUP BY id')
tpm <- tpm[, which(!grepl("gene", colnames(tpm)))]
rownames(tpm) <- tpm$id
tpm <- t(tpm[, -1])
tpm <- log(1+tpm)     ## NOTE THAT WE HAVE LOGGED THE EXPRESSION DATA

treatments <- dbGetQuery(db, 'SELECT * FROM treatments')

```

### Check for and remove strongly outlying samples
```{r}
nmds.output <- dist(tpm) %>% nmds()
data.frame(id = rownames(tpm), nmds.output$conf[[length(nmds.output$conf)]], stringsAsFactors = F) %>% left_join(treatments, by = "id")  %>% ggplot(aes(X1,X2, shape = species)) + geom_point(aes(colour = treatment)) + geom_text_repel(aes(label = id), size=3.6) + xlab("NMDS 1") + ylab("NMDS 2")

tpm <- tpm[!(rownames(tpm) %in% c("lf2", "lf15", "ln9", "ln10")), ]
treatments <- treatments[!(treatments$id %in% c("lf2", "lf15", "ln9", "ln10")), ] # am5 is also a little weird

# Check that everything is ok with the data, as judged by WGCNA package - yes it is
goodSamplesGenes(tpm)$allOK

```

### Have a look at the clustering now that the outliers have been removed
```{r}
nmds.output <- dist(tpm) %>% nmds()
data.frame(id = rownames(tpm), nmds.output$conf[[length(nmds.output$conf)]], stringsAsFactors = F) %>% left_join(treatments, by = "id")  %>% ggplot(aes(X1,X2)) + geom_point(aes(shape = species, colour = treatment)) + geom_text_repel(aes(label = id), size=3.6) + xlab("NMDS 1") + ylab("NMDS 2")
```

### First we need to choose a 'soft thresholding power' for the construction of the network
```{r}
threshold.powers <- pickSoftThreshold(tpm, powerVector = 1:30, verbose = 0) # We choose power 1

threshold.powers[[2]] %>% ggplot(aes(x = Power, y = SFT.R.sq)) + geom_hline(yintercept = 0.9,linetype=2) + geom_point() + geom_line()
```

```{r}
soft.power <- 1
# Make the network using the all-in-one function from WGCNA
network <- blockwiseModules(tpm, power = soft.power,
                            networkType = "unsigned", 
                            minModuleSize = 30,
                            maxBlockSize = 9000,
                            deepSplit = 2, 
                            pamRespectsDendro = FALSE,
                            ht = 0.25, numericLabels = TRUE, 
                            saveTOMs = FALSE, verbose = 0)
```

### Here is the number of genes per module:
```{r}
table(network$colors)
```

### Now plot the network to look at the modules that we identified
```{r}
module.cluster.plot <- function(network){
  moduleColors <- labels2colors(c(0,1:max(network$colors)))
  sizeGrWindow(12,6)
  # Use the layout function for more involved screen sectioning
  layout(matrix(1:2, 2), heights = c(0.8, 0.2), widths = c(1,1))
  #layout.show(4);
  
  # Plot the consensus network dendrogram and the module colors underneath for each block
  plotDendroAndColors(network$dendrograms[[1]], moduleColors[1 + network$colors],
                      "Module colors",
                      main = "Gene dendrogram and module colors",
                      dendroLabels = FALSE, hang = 0.03,
                      addGuide = TRUE, guideHang = 0.05,
                      setLayout = FALSE)
}

module.cluster.plot(network)
```

### Plot the eigengene for each combination of species, treatment and module
```{r}
eigengenes <- data.frame(id = rownames(tpm), network$MEs, stringsAsFactors = F) %>%
  left_join(treatments, by = "id") %>%
  gather(key = module, value = eigengene, starts_with("ME")) %>%
  mutate(colony = paste(species, colony, sep=""),
         module = factor(module, levels = paste("ME", 0:length(unique(module)), sep="")))

eigengenes %>% ggplot(aes(x = species, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")

```

### Examine just the honeybee data
```{r}
eigengenes %>% filter(species == "am") %>% ggplot(aes(x = treatment, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")
```

### Examine just the bumblebee data
```{r}
eigengenes %>% filter(species == "bt") %>% ggplot(aes(x = treatment, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")
```

### Examine just the _L. flavus_ data
```{r}
eigengenes %>% filter(species == "lf") %>% ggplot(aes(x = treatment, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")
```

### Examine just the _L. niger_ data
```{r}
eigengenes %>% filter(species == "ln") %>% ggplot(aes(x = treatment, y = eigengene, fill = treatment)) + 
  geom_boxplot() + facet_wrap(~module, scales = "free")
```

### Run a linear mixed model on each module
```{r}
mods <- unique(eigengenes$module)
outputs <- list()

for(i in 1:length(mods)) outputs[[i]] <- Anova(lmer(eigengene ~ species + treatment + (1|colony), 
                                                    data = eigengenes[eigengenes$module == mods[i], ]), Type = "III")
names(outputs) <- paste("Results for module", mods)
outputs
```